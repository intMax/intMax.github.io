<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>intMax&#39;Blog</title>
  <subtitle>an iOS developer&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://intMax.github.io/"/>
  <updated>2016-10-05T06:03:54.000Z</updated>
  <id>http://intMax.github.io/</id>
  
  <author>
    <name>intMax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解UIButton的imageEdgeInsets和titleEdgeInsets</title>
    <link href="http://intMax.github.io/2016/04/10/uibutton-edgeinsets/"/>
    <id>http://intMax.github.io/2016/04/10/uibutton-edgeinsets/</id>
    <published>2016-04-09T16:00:00.000Z</published>
    <updated>2016-10-05T06:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>UIButton在日常开发中经常用到，也经常需要做一些定制，这些定制很简单，就是改变image和title的位置而已，默认的image和title位置是这样的：<br><img src="/uploads/pic-0.jpg" alt="image"><br>但你拿到的设计稿却经常是这样的：<br><img src="/uploads/pic-1.jpg" alt="image"><br>有些朋友可能被“毫无规律”的imageEdgeInsets和titleEdgeInsets虐过，所以用UIImageView和UILabel的组合来代替了。本篇博客希望用最简单粗暴的方式–实验，来了解一下imageEdgeInsets和titleEdgeInsets到底是怎么玩的。这是我实验的<a href="https://github.com/intMax/DMTButton" target="_blank" rel="external">Demo</a>，帮你免去了改个数据就要cmd-R的烦恼。</p>
<h2 id="contentVerticalAlignment和contentHorizontalAlignment"><a href="#contentVerticalAlignment和contentHorizontalAlignment" class="headerlink" title="contentVerticalAlignment和contentHorizontalAlignment"></a>contentVerticalAlignment和contentHorizontalAlignment</h2><p>这两个属性是UIControl的，是用来排列内部元素的，用好他们，可以让我们的计算轻松一点。先来看看他们的值：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentVerticalAlignment</span>) &#123;</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentCenter</span>  = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentTop</span>     = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentBottom</span>  = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentFill</span>    = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentHorizontalAlignment</span>) &#123;</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentCenter</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentLeft</span>   = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentRight</span>  = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentFill</span>   = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>4x4总共16种选择，只截了其中4种效果，默认是第一种，其他效果自行脑补：<br><img src="/uploads/pic-2.jpg" alt="image"><br>这里有个令人困惑的地方是，为什么选择UIControlContentHorizontalAlignmentFill时，image和title是这种样子的，而不是想象中的填满。这里可以告诉大家，如果只有image时，完全就是大家想象中的样子，如果只有title时，和UIControlContentHorizontalAlignmentLeft的效果一样，都居左，原因是，title不能像图片一样被拉伸，而只能在宽度被偏小时显示<code>...</code>。至于image和title同时存在时，为什么会是这样，在下一节会解释。</p>
<p>接下来说下我个人是怎么来让计算轻松点的吧，我会把<code>contentVerticalAlignment</code>设为<code>top</code>，<code>contentHorizontalAlignment</code>设为<code>left</code>，这样一来就符合了我们以左上角为坐标原点开始布局的惯性思维。当然这只是一种建议，也许有些人觉得从默认状态计算更加方便，我也赞同，毕竟imageEdgeInsets和titleEdgeInsets只是偏移量，和初始位置在哪并没有什么关系。</p>
<h2 id="imageEdgeInsets和titleEdgeInsets"><a href="#imageEdgeInsets和titleEdgeInsets" class="headerlink" title="imageEdgeInsets和titleEdgeInsets"></a>imageEdgeInsets和titleEdgeInsets</h2><p>上面说了，我喜欢把Alignment设为left-top，所以我一开始的位置是这样的：<br><img src="/uploads/pic-3.jpg" alt="image"><br>因为在初始状态下，imageEdgeInsets和titleEdgeInsets都是0，所以在计算偏移量时，image的top-left-bottom以及title的top-bottom-right均能以button的边界最为参考，那image的right和title的left到底是以上面为参考呢，其实，image的right还是是button的边界为参考的，而title的left却是以image的left为参考的，这也正解释了上一节的疑问，为什么UIControlContentHorizontalAlignmentFill是那种样子的，具体请看图：<br><img src="/uploads/pic-4.jpg" alt="image"><br>搞清楚了这个以后，我们在实际做一个背景小节中介绍的image在上，title在下的button：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> imageTop = (button.height-image.height-title.height)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> titleTop = imageTop+image.height;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> imageLeft = (button.width-image.width)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这里减了image.width，因为title的left是以image的left为参考</span></span><br><span class="line"><span class="built_in">CGFloat</span> titleLeft = (button.width-title.widht)/<span class="number">2</span>-image.width;</span><br><span class="line"></span><br><span class="line">button.imageEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(imageTop, imageLeft, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">button.titleEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(titleTop, titleLeft, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>还有个问题，不知道大家看出来了没有？虽说left-top就能确定位置，但是不是就说right-bottom就没什么用了呢？像我这里全设为了0。答案是否定的，而且这也牵扯出了另一个问题—约束的优先级。先上个结论：</p>
<ul>
<li>top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; imageView不能被压缩</li>
<li>top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; titleLabel水平方向不能被压缩</li>
<li>titleLabel垂直方向不能被压缩 &gt; 不能超出button边界</li>
</ul>
<p>这里的将image和title分开来的原因是这样的：imageView的宽高都能被压缩，titleLabel的宽只能压缩不能拉伸，titleLabel的高只能拉伸不能压缩。从上面三条规则中也能看出，想要超出button边界，只要top-left-bottom-right取负值就行了，当然title在垂直方向上由于不能被压缩，即使是正值也能超出。</p>
<p>接下来拿出实验数据来证明下结论：<br><img src="/uploads/pic-5.jpg" alt="image"></p>
<p>到这里，基本上已经能用好imageEdgeInsets和titleEdgeInsets了，那么还有一个问题，不知道大家注意到没有，title和image是能够超出button边界的，这个其实Apple doc是已经说明说了：</p>
<p>imageEdgeInsets和titleEdgeInsets:</p>
<blockquote>
<p>This property is used only for positioning the image during layout. The button does not use this property to determine intrinsicContentSize and sizeThatFits:.</p>
</blockquote>
<p>contentEdgeInsets:</p>
<blockquote>
<p>The button uses this property to determine intrinsicContentSize and sizeThatFits:.</p>
</blockquote>
<p>所以，如果大家想让image和title在设置insets时不超出边界，只需要同时调整下contentEdgeInsets即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前也被imageEdgeInsets和titleEdgeInsets困扰过，就用了UIImageView和UILabel的组合来代替，为了不影响开发进度，也只能这样做，毕竟靠这个吃饭，不过在技术层面，这你能忍？结束。如有问题，请勘误。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://stackoverflow.com/questions/4564621/aligning-text-and-image-on-uibutton-with-imageedgeinsets-and-titleedgeinsets/5358259#5358259" target="_blank" rel="external">参考链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;UIButton在日常开发中经常用到，也经常需要做一些定制，这些定制很简单，就是改变image和title的位置而已，默认的image和ti
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="实用技巧" scheme="http://intMax.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;三&gt;</title>
    <link href="http://intMax.github.io/2015/08/30/effective-objective-c-3/"/>
    <id>http://intMax.github.io/2015/08/30/effective-objective-c-3/</id>
    <published>2015-08-29T16:00:00.000Z</published>
    <updated>2016-03-27T10:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-内存管理"><a href="#第五章-内存管理" class="headerlink" title="第五章 内存管理"></a>第五章 内存管理</h2><p>1.ARC并不会调用<code>retain</code>、<code>release</code>等方法，而是直接调用其底层C语言版本<code>objc_retain</code>等，所以ARC没有普通的OC消息派发机制。</p>
<p>2.如果<code>setter</code>方法像下面这样写，当新值和旧值相同时就程序就会崩溃。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object&#123;</span><br><span class="line">    [_object release];</span><br><span class="line">    _object=[object retain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.ARC中的命名规则：如果方法名以<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>开头，则返回对象归调用者所有，否则返回的对象会自动释放。</p>
<p>4.dealloc方法里要释放指向其他对象的引用，取消键值观测（KVO）和<code>NSNotificationCenter</code>通知，不要在这里执行异步任务或应该在正常状态下执行的任务，因为这是的对象已经处于正在回收状态了。</p>
<p>5.ARC默认不生成安全处理异常的代码，设置-fobjc-arc-exceptions标志后可以开启，不过会导致应用程序变大，效率变低。</p>
<p>6.<code>unsafe_unretain</code>和<code>weak</code>都可以用来消除循环引用，区别是前者在引用移除后仍然指向已经回收的对象，后者则会自动设为<code>nil</code>，所以使用<code>weak</code>会安全一点，因为向<code>nil</code>发送消息不会报错。</p>
<p>7.利用自动释放池可以避免内存峰值的出现。</p>
<h2 id="第六章-块与大中枢派发"><a href="#第六章-块与大中枢派发" class="headerlink" title="第六章 块与大中枢派发"></a>第六章 块与大中枢派发</h2><p>1.下图是块的内部结构：<br><img src="/uploads/block.jpg" alt="image" title="block"><br>上图中首个变量是个isa指针，所以块本身是一个对象。那么块和普通函数有什么区别呢？除了块是个对象外，其实最大的区别就是块比函数多了个上下文环境，块内部可以调用外部的变量，对应上图的<code>variables</code>，而<code>descriptor</code>内部则会对捕获的变量进行管理。</p>
<p>2.块分为全局块（<code>NSConcreteGlobalBlock</code>）、栈块（<code>NSConcreteStackBlock</code>）、堆块（<code>NSConcreteMallocBlock</code>），在ARC中只有全局块和堆块了。</p>
<p>3.利用<code>typedef</code>创建块，然后将handler块作为参数传给方法，以降低代码分散程度。这种方法编写类的时候特别要注意块的保留环，记得要把块在适当时机释放掉，解除保留环。在AFNetworking中，是把所有competition块保存在字典中，当请求结束时，再移除，其他开源库的做法也都大同小异。</p>
<p>4.GCD和<code>NSOperationQueue</code>：前者是纯C的API，且更加轻量，后者是Objective-C对象，可以取消操作、设置依赖关系、同一队列中各操作的优先级设置。</p>
<p>5.不要使用<code>dispatch_get_current_queue</code>，因为往往A线程里面又有B线程，所以在B中检测当前线程就会产生歧义。</p>
<h2 id="第七章-系统框架"><a href="#第七章-系统框架" class="headerlink" title="第七章 系统框架"></a>第七章 系统框架</h2><p>1.多用块枚举，少用for循环，另外也可以使用for in这种快速遍历的方法。</p>
<p>2.<code>load</code>和<code>initialize</code>里面的代码一定要精简。不要在里面调用其他类的方法，因为多个类之间执行<code>load</code>的顺序是不确定的，而且<code>load</code>不参与继承机制。<code>initialize</code>会在类被第一次调用时执行一次，和<code>load</code>一样，不要再里面调用其他类的方法。</p>
<p>3.<code>NSTimer</code>会保留目标对象，所以很容易造成循环引用，调用<code>invalidate</code>方法可以使timer失效，但是别把这项工作交给调用者，你永远无法保证调用者一定会调用<code>invalidate</code>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这本书其实早就看完了，写这几篇博客时，这本书差不多看了快三遍了，里面很多知识点对提升编程质量还是很有帮助的，在看一些开源iOS框架的时候，很多细节上的处理都能在这本书上找到解释。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第五章-内存管理&quot;&gt;&lt;a href=&quot;#第五章-内存管理&quot; class=&quot;headerlink&quot; title=&quot;第五章 内存管理&quot;&gt;&lt;/a&gt;第五章 内存管理&lt;/h2&gt;&lt;p&gt;1.ARC并不会调用&lt;code&gt;retain&lt;/code&gt;、&lt;code&gt;release&lt;/c
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;二&gt;</title>
    <link href="http://intMax.github.io/2015/08/02/effective-objective-c-2/"/>
    <id>http://intMax.github.io/2015/08/02/effective-objective-c-2/</id>
    <published>2015-08-01T16:00:00.000Z</published>
    <updated>2016-03-27T10:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-接口与API设计"><a href="#第三章-接口与API设计" class="headerlink" title="第三章 接口与API设计"></a>第三章 接口与API设计</h2><p>1.Objective-C没有命名空间，所以在命名上最好加上前缀以减小冲突的可能，前缀建议采用三个字母（苹果保留使用所有两个字母前缀的权利）。在开发自己的类库时如果用了其他第三方类库，最好将第三方类库也加上前缀，这样可以让使用者使用你的类库的同时也用你的类库中用到第三方类库（有点绕. . .）。</p>
<p>2.覆写<code>description</code>方法，打印出一些有用信息帮助调试。</p>
<p>3.封装一个对象时，对外公开属性最好是只读(<code>readonly</code>)的，如果要在内部修改可在对象内部重新声明为readwrite。这种模式在AFNetworking有着大量的应用。</p>
<p>4.私有方法最好加上前缀(p<em> )，前缀不要只用一个下划线(</em>)，这种做法是苹果预留的。</p>
<p>5.容器类对象默认执行的是浅拷贝，若要执行深拷贝需要自己编写相关方法。</p>
<h2 id="第四章-协议与分类"><a href="#第四章-协议与分类" class="headerlink" title="第四章 协议与分类"></a>第四章 协议与分类</h2><p>1.委托属性常用weak来修饰；一个协议里的方法是<code>optional</code>的，需要先判断委托对象是否实现改方法，如果经常需要判断则可考虑做个缓存。</p>
<p>2.<code>weak</code>和<code>unsafe_unretain</code>的区别是前者在相关对象销毁时需要自动清空，后者则不需要。</p>
<p>3.分类中不要添加属性，必须添加的话可以采用关联对象机制模拟，不推荐。分类的设计初衷是扩展类的功能，而属性是用于数据的封装，因此，属性最好定义在主接口中。</p>
<p>4.<code>class-continuation</code>分类（在其他地方看到过叫匿名分类），这本书多次提到了这个概念，对应的部分是：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SonClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SonClass</span> : <span class="title">FatherClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SonClass.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SonClass</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//class-continuation分类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>5.<code>class-continuation</code>分类可以用来隐藏实现细节，如系统的WebKit其实大部分是C++编写的，但是对外展示的却是一套整洁的Objective-C接口。</p>
<p>6.匿名对象，常见的有：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;MyDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></p>
<p>这句话的意思是delegate遵循MyDelegate协议，至于它本身是什么类不关心。匿名分类也可以用来对一些第三方类库进行一些简单封装：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyDatabaseConnection</span></span></span><br><span class="line">-(<span class="keyword">void</span>)connect;</span><br><span class="line">-(<span class="keyword">void</span>)disconnect;</span><br><span class="line">-(<span class="built_in">BOOL</span>)isConnected;</span><br><span class="line">-(<span class="built_in">NSArray</span> *)performQuery:(<span class="built_in">NSString</span>*)query;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">@ protocol MyDatabaseConnection;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDatabaseManager</span> : <span class="title">NSObject</span></span></span><br><span class="line">+sharedInstance;</span><br><span class="line">-(<span class="keyword">id</span>&lt;MyDatabaseConnection&gt;)connectionWithIdentifier:(<span class="built_in">NSString</span>*)identifier;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这里隐藏了数据库连接所用的类（可能来自不同框架），而且在后续中，无需改变公共API，就能切换后端实现类。</p>
<p>6.关于匿名分类的一个面试题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span>、<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;、<span class="built_in">NSObject</span>的区别</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSObject</span>：就是用来定义<span class="built_in">NSObject</span>对象的。</span><br><span class="line"><span class="keyword">id</span>：它就是一个指针，它可以指向的类型不仅限于<span class="built_in">NSObject</span>，如<span class="built_in">NSProxy</span>。</span><br><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;：它指向的对象要求实现<span class="built_in">NSObject</span>所实现的协议，所以说它可以定义<span class="built_in">NSObject</span>、<span class="built_in">NSProxy</span>（它也实现了&lt;<span class="built_in">NSObject</span>&gt;）或者其他实现了&lt;<span class="built_in">NSObject</span>&gt;的对象。</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-接口与API设计&quot;&gt;&lt;a href=&quot;#第三章-接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;第三章 接口与API设计&quot;&gt;&lt;/a&gt;第三章 接口与API设计&lt;/h2&gt;&lt;p&gt;1.Objective-C没有命名空间，所以在命名上最好加上
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;一&gt;</title>
    <link href="http://intMax.github.io/2015/07/15/effective-objective-c-1/"/>
    <id>http://intMax.github.io/2015/07/15/effective-objective-c-1/</id>
    <published>2015-07-14T16:00:00.000Z</published>
    <updated>2016-03-27T10:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-熟悉Objective-C"><a href="#第一章-熟悉Objective-C" class="headerlink" title="第一章 熟悉Objective-C"></a>第一章 熟悉Objective-C</h2><p>1.OC使用动态绑定的消息结构，在runtime才会检查对象类型、决定执行何种代码。runtime是很多功能的基础，如分类、动态添加类等</p>
<p>2.@class可以向前声明一个类，类似的还有@protocol，这两个关键字告诉编译器我是有这个类或者协议的。</p>
<p>3.#import不会引起引用头文件死循环和重复引用，它会自动让其中一个失效，而#include用来引用C或C++类型的头文件，会引起死循环。</p>
<p>4.考虑以下代码：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1=<span class="comment">/*. . .*/</span>;</span><br><span class="line"><span class="keyword">id</span> obj2=<span class="comment">/*. . .*/</span>;</span><br><span class="line"><span class="keyword">id</span> obj3=<span class="comment">/*. . .*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *arrayA=[<span class="built_in">NSArray</span> arrayWithObjects:obj1,obj2,obj3,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *arrayB=@[obj1,obj2,obj3];</span><br></pre></td></tr></table></figure></p>
<p>如果obj2=nil会怎样？显然后者初始化数组会报错，而前者虽然不会报错，但是将只有一个对象ojb1。对于前者这很可能不是我们想要的结果，会导致后面出现bug很难追踪，所以推荐使用后者的方式初始化，这样就能尽快定位到问题所在。</p>
<p>5.多用类型常量，少用#define预处理命令。用extern关键字可对外公开某个常量，AFNetworking中常用这种方式来对外公布一个NSNotification标识符。</p>
<p>6.枚举尽量用NS_ENUM和NS_OPTIONS宏来定义，这样可以确保枚举是指定的数据类型来实现的。后者还可进行按位或、按位与运算</p>
<h2 id="第二章-对象、消息、运行期"><a href="#第二章-对象、消息、运行期" class="headerlink" title="第二章 对象、消息、运行期"></a>第二章 对象、消息、运行期</h2><p>1.@synthesis和@dynamic，前者会由编译器在编译期间自动生成getter、setter（假设属性是readwrite），后者告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告。自定义getter、setter可以选择重载他们，也可以在利用runtime期的消息转发机制来实现。</p>
<blockquote>
<p>这里插两点：第一，不要在重载的setter方法里有这样的写法self.property=property，应该改为_property=property，否则会引起一个无限循环，这本书在这里的写法是错误的。那么如果要在子类重载这个setter方法该怎么办呢？子类没有_property这个实例变量。这时，可以在子类的实现文件中加上@synthesize property = _property。其实我一开始的想法是用self-&gt;_property来访问的，但是编译不通过。第二，如果同时覆写了getter和setter方法，那么属性对应的实例变量就不存在了，需要自己手动添加。</p>
</blockquote>
<p>2.在对象外部总是应该通过属性来访问实例变量，那么在对象内部呢？直接用实例变量访问速度快，但是会绕过属性特质（copy等），更重要的是不会触发KVO。这本书给的建议的是：写入实例变量时应该用setter方法，而在读取时则直接访问。</p>
<p>3.尽量避免将可变对象放入容器，容器内部会根据哈希码来对各个对象进行分箱，这意味着在对象被放入容器的时候已经被分好了，如果后来改变了对象，哈希码也会随着改变，这样，之前的分箱就有问题了。</p>
<p>4.类簇，系统框架中普遍使用了这种模式，如UIButton、NSArray等。以前做网站的时候用过工厂模式，其实类簇基类的内部就是一个工厂，根据传入的参数分别创建相应的对象。相信平常接触比较多的是分类而非类簇，那么两者有什么区别呢？首先，类簇可以隐藏基类背后的具体实现（当然，由于runtime的存在，想要真正隐藏是不可能的），其次，可以用isKindOfClass和isMemberOfClass试试看声明出来的对象是否属于对应的类。类簇声明的对象永远不可能是该基类。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> maybeAnArray=<span class="comment">/*. . .*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>([maybeAnArray class] == [<span class="built_in">NSArray</span> class])&#123;</span><br><span class="line"><span class="comment">//will never be hit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>([[maybeAnArray class] isKindOfClass:[<span class="built_in">NSArray</span> class]])&#123;</span><br><span class="line"><span class="comment">//will be hit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.对象关联机制，运用这种机制可以给分类模拟添加属性，不同属性可以用“键”来区分，属性特质可以用关联类型来表示（OBJC_ASSOCIATION_COPY等）。但是建议不到万不得已的时候不要用这种方法，否则出现“保留环”等内存bug将很难追踪。</p>
<p>6.消息转发机制<br><img src="/uploads/forwarding.jpg" alt="image" title="forwarding"><br>在重写forwardInvocation:时，也要重写methodSignatureForSelector:方法，用来返回相应的方法签名，便于生成一个NSInvocation传递给forwardInvocation:。最后消息未能处理会调用NSObjec的doseNotRecognizeSelector:方法抛出异常。消息传递越往后消耗越大，像@dynamic在resolveInstanceMethod:阶段就可以完成。模拟多继承可以在forwardingTargetForSelector:完成。</p>
<p>7.方法混写可以交换两个方法的实现、替代原方法的实现等，这项技术一般用于调试，但是最近在看AFNetworking源码时发现，他也用了这项技术，NSURLSessionTask是一个类簇，在iOS7、iOS8中内部继承关系有点不一样，所以用到了这项技术来替换原有的resume、suspend方法。</p>
<p>8.类对象，每个对象有一个isa指针，指向对应的类，其结构如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;  </span><br><span class="line">    Class isa;  </span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;  </span><br><span class="line">    Class isa;  </span><br><span class="line">    Class super_class;  </span><br><span class="line">    <span class="keyword">const</span> charchar *name;  </span><br><span class="line">    <span class="keyword">long</span> version;  </span><br><span class="line">    <span class="keyword">long</span> info;  </span><br><span class="line">    <span class="keyword">long</span> instance_size;  </span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;  </span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;  </span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;  </span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;  </span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>显然Class本身也是个对象，它指向一个叫“元类（metaclass）”的类，类方法就定义在这里。元类的继承关系和类一样，它继承自父类的元类。根类的元类指针指向自己，从而形成闭环。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章-熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第一章-熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第一章 熟悉Objective-C&quot;&gt;&lt;/a&gt;第一章 熟悉Objective-C&lt;/h2&gt;&lt;p&gt;1.OC使用动态绑定
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
