<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>intMax&#39;Blog</title>
  <subtitle>an iOS developer&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://intMax.github.io/"/>
  <updated>2016-04-10T13:02:30.000Z</updated>
  <id>http://intMax.github.io/</id>
  
  <author>
    <name>intMax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解UIButton的imageEdgeInsets和titleEdgeInsets</title>
    <link href="http://intMax.github.io/2016/04/10/uibutton-edgeinsets/"/>
    <id>http://intMax.github.io/2016/04/10/uibutton-edgeinsets/</id>
    <published>2016-04-09T16:00:00.000Z</published>
    <updated>2016-04-10T13:02:30.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;UIButton在日常开发中经常用到，也经常需要做一些定制，这些定制很简单，就是改变image和title的位置而已，默认的image和title位置是这样的：&lt;br&gt;&lt;img src=&quot;/uploads/pic-0.jpg&quot; alt=&quot;image&quot; title=&quot;pic-0&quot;&gt;&lt;br&gt;但你拿到的设计稿却经常是这样的：&lt;br&gt;&lt;img src=&quot;/uploads/pic-1.jpg&quot; alt=&quot;image&quot; title=&quot;pic-1&quot;&gt;&lt;br&gt;有些朋友可能被“毫无规律”的imageEdgeInsets和titleEdgeInsets虐过，所以用UIImageView和UILabel的组合来代替了。本篇博客希望用最简单粗暴的方式–实验，来了解一下imageEdgeInsets和titleEdgeInsets到底是怎么玩的。这是我实验的&lt;a href=&quot;https://github.com/intMax/DMTButton&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;，帮你免去了改个数据就要cmd-R的烦恼。&lt;/p&gt;
&lt;h2 id=&quot;contentVerticalAlignment和contentHorizontalAlignment&quot;&gt;&lt;a href=&quot;#contentVerticalAlignment和contentHorizontalAlignment&quot; class=&quot;headerlink&quot; title=&quot;contentVerticalAlignment和contentHorizontalAlignment&quot;&gt;&lt;/a&gt;contentVerticalAlignment和contentHorizontalAlignment&lt;/h2&gt;&lt;p&gt;这两个属性是UIControl的，是用来排列内部元素的，用好他们，可以让我们的计算轻松一点。先来看看他们的值：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIControlContentVerticalAlignment&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentVerticalAlignmentCenter&lt;/span&gt;  = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentVerticalAlignmentTop&lt;/span&gt;     = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentVerticalAlignmentBottom&lt;/span&gt;  = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentVerticalAlignmentFill&lt;/span&gt;    = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIControlContentHorizontalAlignment&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentHorizontalAlignmentCenter&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentHorizontalAlignmentLeft&lt;/span&gt;   = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentHorizontalAlignmentRight&lt;/span&gt;  = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIControlContentHorizontalAlignmentFill&lt;/span&gt;   = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4x4总共16种选择，只截了其中4种效果，默认是第一种，其他效果自行脑补：&lt;br&gt;&lt;img src=&quot;/uploads/pic-2.jpg&quot; alt=&quot;image&quot; title=&quot;pic-2&quot;&gt;&lt;br&gt;这里有个令人困惑的地方是，为什么选择UIControlContentHorizontalAlignmentFill时，image和title是这种样子的，而不是想象中的填满。这里可以告诉大家，如果只有image时，完全就是大家想象中的样子，如果只有title时，和UIControlContentHorizontalAlignmentLeft的效果一样，都居左，原因是，title不能像图片一样被拉伸，而只能在宽度被偏小时显示&lt;code&gt;...&lt;/code&gt;。至于image和title同时存在时，为什么会是这样，在下一节会解释。&lt;/p&gt;
&lt;p&gt;接下来说下我个人是怎么来让计算轻松点的吧，我会把&lt;code&gt;contentVerticalAlignment&lt;/code&gt;设为&lt;code&gt;top&lt;/code&gt;，&lt;code&gt;contentHorizontalAlignment&lt;/code&gt;设为&lt;code&gt;left&lt;/code&gt;，这样一来就符合了我们以左上角为坐标原点开始布局的惯性思维。当然这只是一种建议，也许有些人觉得从默认状态计算更加方便，我也赞同，毕竟imageEdgeInsets和titleEdgeInsets只是偏移量，和初始位置在哪并没有什么关系。&lt;/p&gt;
&lt;h2 id=&quot;imageEdgeInsets和titleEdgeInsets&quot;&gt;&lt;a href=&quot;#imageEdgeInsets和titleEdgeInsets&quot; class=&quot;headerlink&quot; title=&quot;imageEdgeInsets和titleEdgeInsets&quot;&gt;&lt;/a&gt;imageEdgeInsets和titleEdgeInsets&lt;/h2&gt;&lt;p&gt;上面说了，我喜欢把Alignment设为left-top，所以我一开始的位置是这样的：&lt;br&gt;&lt;img src=&quot;/uploads/pic-3.jpg&quot; alt=&quot;image&quot; title=&quot;pic-3&quot;&gt;&lt;br&gt;因为在初始状态下，imageEdgeInsets和titleEdgeInsets都是0，所以在计算偏移量时，image的top-left-bottom以及title的top-bottom-right均能以button的边界最为参考，那image的right和title的left到底是以上面为参考呢，其实，image的right还是是button的边界为参考的，而title的left却是以image的left为参考的，这也正解释了上一节的疑问，为什么UIControlContentHorizontalAlignmentFill是那种样子的，具体请看图：&lt;br&gt;&lt;img src=&quot;/uploads/pic-4.jpg&quot; alt=&quot;image&quot; title=&quot;pic-4&quot;&gt;&lt;br&gt;搞清楚了这个以后，我们在实际做一个背景小节中介绍的image在上，title在下的button：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; imageTop = (button.height-image.height-title.height)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; titleTop = imageTop+image.height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; imageLeft = (button.width-image.width)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这里减了image.width，因为title的left是以image的left为参考&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; titleLeft = (button.width-title.widht)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-image.width;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;button.imageEdgeInsets = &lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(imageTop, imageLeft, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;button.titleEdgeInsets = &lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(titleTop, titleLeft, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;还有个问题，不知道大家看出来了没有？虽说left-top就能确定位置，但是不是就说right-bottom就没什么用了呢？像我这里全设为了0。答案是否定的，而且这也牵扯出了另一个问题—约束的优先级。先上个结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;top-left-bottom-right取负值 &amp;gt; 不能超出button边界 &amp;gt; imageView不能被压缩&lt;/li&gt;
&lt;li&gt;top-left-bottom-right取负值 &amp;gt; 不能超出button边界 &amp;gt; titleLabel水平方向不能被压缩&lt;/li&gt;
&lt;li&gt;titleLabel垂直方向不能被压缩 &amp;gt; 不能超出button边界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的将image和title分开来的原因是这样的：imageView的宽高都能被压缩，titleLabel的宽只能压缩不能拉伸，titleLabel的高只能拉伸不能压缩。从上面三条规则中也能看出，想要超出button边界，只要top-left-bottom-right取负值就行了，当然title在垂直方向上由于不能被压缩，即使是正值也能超出。&lt;/p&gt;
&lt;p&gt;接下来拿出实验数据来证明下结论：&lt;br&gt;&lt;img src=&quot;/uploads/pic-5.jpg&quot; alt=&quot;image&quot; title=&quot;pic-5&quot;&gt;&lt;/p&gt;
&lt;p&gt;到这里，基本上已经能用好imageEdgeInsets和titleEdgeInsets了，那么还有一个问题，不知道大家注意到没有，title和image是能够超出button边界的，这个其实Apple doc是已经说明说了：&lt;/p&gt;
&lt;p&gt;imageEdgeInsets和titleEdgeInsets:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This property is used only for positioning the image during layout. The button does not use this property to determine intrinsicContentSize and sizeThatFits:.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;contentEdgeInsets:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The button uses this property to determine intrinsicContentSize and sizeThatFits:.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，如果大家想让image和title在设置insets时不超出边界，只需要同时调整下contentEdgeInsets即可。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;之前也被imageEdgeInsets和titleEdgeInsets困扰过，就用了UIImageView和UILabel的组合来代替，为了不影响开发进度，也只能这样做，毕竟靠这个吃饭，不过在技术层面，这你能忍？结束。如有问题，请勘误。&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4564621/aligning-text-and-image-on-uibutton-with-imageedgeinsets-and-titleedgeinsets/5358259#5358259&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考链接&lt;/a&gt;&lt;br&gt;请我喝杯咖啡&lt;br&gt;&lt;img src=&quot;/uploads/alipay.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;UIButton在日常开发中经常用到，也经常需要做一些定制，这些定制很简单，就是改变image和title的位置而已，默认的image和ti
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="实用技巧" scheme="http://intMax.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>根据View的优先级有序展示在Window上</title>
    <link href="http://intMax.github.io/2016/04/05/dmt-window-manager/"/>
    <id>http://intMax.github.io/2016/04/05/dmt-window-manager/</id>
    <published>2016-04-04T16:00:00.000Z</published>
    <updated>2016-04-07T13:21:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h3 id=&quot;场景一&quot;&gt;&lt;a href=&quot;#场景一&quot; class=&quot;headerlink&quot; title=&quot;场景一&quot;&gt;&lt;/a&gt;场景一&lt;/h3&gt;&lt;p&gt;打开App时，不同组件会根据运营的要求弹出各自的活动弹窗，最简单的做法是每个组件自己把活动视图&lt;code&gt;makeKeyAndVisbile&lt;/code&gt;设为keyWindow，或者&lt;code&gt;[keyWindow addSubview:]&lt;/code&gt;，但是这样就出现了谁先谁后的问题，这时，组件的开发人员就需要和对应的运营确认哪个活动优先级更高。优先级高的显示完了，还要通知优先级低的，下一个活动时，发现两个组件弹窗的优先级被调换了一下，崩溃…&lt;/p&gt;
&lt;h3 id=&quot;场景二&quot;&gt;&lt;a href=&quot;#场景二&quot; class=&quot;headerlink&quot; title=&quot;场景二&quot;&gt;&lt;/a&gt;场景二&lt;/h3&gt;&lt;p&gt;如果说场景一的需求太少见（的确，哪个产品会让用户一进App看两个弹窗？），这个场景似乎很常见。在用户使用的过程中，用户触发了两个弹窗，如一个提示，一个普通弹窗，用&lt;code&gt;makeKeyAndVisbile&lt;/code&gt;的方法倒还好，顶多就是遮住了提示，要是用了&lt;code&gt;[keyWindow addSubview:]&lt;/code&gt;的话，你可能会蛋疼的不要的不要的，因为大多数App使用的提示都会统一封装一下，而且大多数是用&lt;code&gt;makeKeyAndVisbile&lt;/code&gt;将其作为keyWindow显示在最上面&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;关于场景一，虽然少见，但也很好解决，给这种活动弹窗设置一个类似&lt;code&gt;UIWindowLevel&lt;/code&gt;的优先级属性，让运营自己定，我们只需要提供一个统一的管理活动弹窗的类，让弹窗根据优先级自己一个一个弹。关于第二个场景，我的想法是限制各组件的视图轻易的成为keyWindow，提供一个入口给那些想显示在最上面的视图，这样我们内部就可以通过一个FIFO的队列来维护秩序，当然也可以通过设置高优先级来插队。有时候，我们在使用时可能需要知道当前队列中的状况，我们可以KVO内部这个队列。效果图：&lt;br&gt;&lt;img src=&quot;/uploads/demo.gif&quot; alt=&quot;image&quot; title=&quot;DMTWindowManagerDemo&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一点说明&quot;&gt;&lt;a href=&quot;#一点说明&quot; class=&quot;headerlink&quot; title=&quot;一点说明&quot;&gt;&lt;/a&gt;一点说明&lt;/h2&gt;&lt;p&gt;下面这小节可以选择跳过&lt;a href=&quot;#code&quot;&gt;skip&lt;/a&gt;，这里写的零零碎碎的，真的要储备建议看下官方文档。当然，大致浏览下是没什么问题的。&lt;br&gt;参考文献：&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWindow_Class/index.html#//apple_ref/occ/cl/UIWindow&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UIWindow&lt;/a&gt;、&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/AccessorConventions.html#//apple_ref/doc/uid/20002174-BAJEAIEE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Key-Value Coding Accessor Methods&lt;/a&gt;、&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSKeyValueObserving&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;知识储备&quot;&gt;&lt;a href=&quot;#知识储备&quot; class=&quot;headerlink&quot; title=&quot;知识储备&quot;&gt;&lt;/a&gt;知识储备&lt;/h2&gt;&lt;h3 id=&quot;UIWindow&quot;&gt;&lt;a href=&quot;#UIWindow&quot; class=&quot;headerlink&quot; title=&quot;UIWindow&quot;&gt;&lt;/a&gt;UIWindow&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 几个属性 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIWindowLevel&lt;/span&gt; windowLevel;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIScreen&lt;/span&gt; *screen;&lt;span class=&quot;comment&quot;&gt;// screen一旦被显示，替换的成本是很高的，但在没有显示前更改是有不会太多消耗的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIViewController&lt;/span&gt; *rootViewController;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, getter=isKeyWindow) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; keyWindow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 操作window的一些方法 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)makeKeyAndVisible;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)becomeKeyWindow;&lt;span class=&quot;comment&quot;&gt;// 系统会在window成为keyWindow时自动调用，不要手动调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)makeKeyWindow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)resignKeyWindow;&lt;span class=&quot;comment&quot;&gt;// 系统会在keyWindow注销时自动调用，不要手动调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 坐标转换 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt;)convertPoint:(&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt;)point toWindow:(&lt;span class=&quot;built_in&quot;&gt;UIWindow&lt;/span&gt; *)window;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt;)convertPoint:(&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt;)point fromWindow:(&lt;span class=&quot;built_in&quot;&gt;UIWindow&lt;/span&gt; *)window;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)convertRect:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)rect toWindow:(&lt;span class=&quot;built_in&quot;&gt;UIWindow&lt;/span&gt; *)window;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)convertRect:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)rect fromWindow:(&lt;span class=&quot;built_in&quot;&gt;UIWindow&lt;/span&gt; *)window;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 所有的事件都是UIApplication传递给UIWindow的这个方法分发下去的 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sendEvent:(&lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很简单的一个类，当我们需要显示一个window时，只需要&lt;code&gt;[window makeKeyAndVisible]&lt;/code&gt;或者&lt;code&gt;[window setHidden:YES]&lt;/code&gt;即可。&lt;/p&gt;
&lt;h3 id=&quot;Key-Value-Coding-实现KVO集合类型的属性&quot;&gt;&lt;a href=&quot;#Key-Value-Coding-实现KVO集合类型的属性&quot; class=&quot;headerlink&quot; title=&quot;Key-Value Coding 实现KVO集合类型的属性&quot;&gt;&lt;/a&gt;Key-Value Coding 实现KVO集合类型的属性&lt;/h3&gt;&lt;p&gt;KVO一个NSString、NSNumber等类型的一些属性时，我们的做法是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Foo addObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; forKeyPath:path options:options context:context];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现该方法，接收变化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)observeValueForKeyPath:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)keyPath ofObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object change:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *,&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;gt; *)change context:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)context&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([keyPath isEqualToString:yourPath])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, change);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; observeValueForKeyPath:keyPath ofObject:object change:change context:context];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 移除观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Foo removeObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; forKeyPath:path context:context];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是当你的属性是个NSArray、NSSet、NSDictionary等集合类型时，你会发现当你添加或者移除元素时并不能接收到变化。因为KVO的本质是系统监测到某个属性的内存地址或常量改变时，会添加上&lt;code&gt;- (void)willChangeValueForKey:(NSString *)key&lt;/code&gt;&lt;br&gt;和&lt;code&gt;- (void)didChangeValueForKey:(NSString *)key&lt;/code&gt;方法来发送通知，所以一种解决方法是手动调用者两个方法，但是并不推荐，你永远无法像系统一样真正知道这个元素什么时候被改变。另一种便是利用Key-Value Coding：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 有序不可变集合，如NSArray&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-countOf&amp;lt;Key&amp;gt;必须实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-objectIn&amp;lt;Key&amp;gt;AtIndex: or -&amp;lt;key&amp;gt;AtIndexes:实现其中一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-get&amp;lt;Key&amp;gt;:range:可选，提升性能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 有序可变集合，如NSMutableArray&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-insertObject:&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&amp;lt;Key&amp;gt;AtIndex: or -insert&amp;lt;Key&amp;gt;:atIndexes:实现至少一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-removeObjectFrom&amp;lt;Key&amp;gt;AtIndex: or -remove&amp;lt;Key&amp;gt;AtIndexes:实现至少一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-replaceObjectIn&amp;lt;Key&amp;gt;AtIndex:withObject: or -replace&amp;lt;Key&amp;gt;AtIndexes:with&amp;lt;Key&amp;gt;:可选&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 需要利用mutableArrayValueForKey:返回的代理操作，如[[self mutableArrayValueForKey:@&quot;key&quot;] addObject:foo];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;上代码&quot;&gt;&lt;a href=&quot;#上代码&quot; class=&quot;headerlink&quot; title=&quot;上代码&quot;&gt;&lt;/a&gt;上代码&lt;a name=&quot;code&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;先看下整个流程吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/DMTWindowManager.jpg&quot; alt=&quot;image&quot; title=&quot;DMTWindowManager&quot;&gt;&lt;/p&gt;
&lt;p&gt;整个流程很简单，使用者只要传入一个View和一个可选的Config，内部会自动根据优先级显示，在移除一个View后，会自动显示下一个，直到没有View可以显示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DMTWindowConfig&lt;/code&gt;里面包含了一些对应View的配置信息，这里只是个Demo，东西比较少，可以根据项目实际情况再配一些：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DMTWindowConfig&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIWindowLevel&lt;/span&gt; windowLevel;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; animation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; ignoreHit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) DMTWindowAnimationHandler addAnimationHandler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) DMTWindowAnimationHandler removeAnimationHandler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;DMTWindowManager&lt;/code&gt;内部维护一个队列，这里的队列其实是个假队列，就是一个NSMutableArray类型的容器，只是在取值的时候支持了FIFO和插队的特性：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *)_getNextView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.queue.count &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.configs.count &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *ret = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.configs.count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.configs[i] windowLevel] &amp;gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.configs[index] windowLevel])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            index = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ret = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.queue objectAtIndex:index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)_enqueue:(&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *)view config:(DMTWindowConfig *)config&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; mutableArrayValueForKey:kViewQueueObserveKeyPath] addObject:view];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.configs addObject:config];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)_dequeue:(&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *)view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.queue.count &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.configs.count &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || ![&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.queue containsObject:view])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; index = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.queue indexOfObject:view];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.configs removeObjectAtIndex:index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; mutableArrayValueForKey:kViewQueueObserveKeyPath] removeObject:view];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果外部需要知道队列中View的添加和移除的情况，可以对&lt;code&gt;kViewQueueObserveKeyPath&lt;/code&gt;这个path进行KVO：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[DMTWindowManager sharedInstance] addObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; forKeyPath:kViewQueueObserveKeyPath options:option context:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 接收变化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)observeValueForKeyPath:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)keyPath ofObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object change:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *,&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;gt; *)change context:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)context&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([keyPath isEqualToString:kViewQueueObserveKeyPath])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, change);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; observeValueForKeyPath:keyPath ofObject:object change:change context:context];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 移除观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[DMTWindowManager sharedInstance] removeObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; forKeyPath:kViewQueueObserveKeyPath context:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体的代码请参考&lt;a href=&quot;https://github.com/intMax/DMTWindowManager&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;整个方案的主要思路是把所有想成为keyWindow的View集中在一起管理，这样就可以有序的展示，也方便增加一些公共的需求，如打点统计等。如有错误，请指正。自从15年秋季校招结束后，很长一段时间没写博客了，一直忙于写业务，只能说需求太饱和了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h3 id=&quot;场景一&quot;&gt;&lt;a href=&quot;#场景一&quot; class=&quot;headerlink&quot; title=&quot;场景一&quot;&gt;&lt;/a&gt;场景一&lt;/h3&gt;&lt;p
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="实用技巧" scheme="http://intMax.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;三&gt;</title>
    <link href="http://intMax.github.io/2015/08/30/effective-objective-c-3/"/>
    <id>http://intMax.github.io/2015/08/30/effective-objective-c-3/</id>
    <published>2015-08-29T16:00:00.000Z</published>
    <updated>2016-03-27T10:27:29.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;第五章-内存管理&quot;&gt;&lt;a href=&quot;#第五章-内存管理&quot; class=&quot;headerlink&quot; title=&quot;第五章 内存管理&quot;&gt;&lt;/a&gt;第五章 内存管理&lt;/h2&gt;&lt;p&gt;1.ARC并不会调用&lt;code&gt;retain&lt;/code&gt;、&lt;code&gt;release&lt;/code&gt;等方法，而是直接调用其底层C语言版本&lt;code&gt;objc_retain&lt;/code&gt;等，所以ARC没有普通的OC消息派发机制。&lt;/p&gt;
&lt;p&gt;2.如果&lt;code&gt;setter&lt;/code&gt;方法像下面这样写，当新值和旧值相同时就程序就会崩溃。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_object release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _object=[object retain];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.ARC中的命名规则：如果方法名以&lt;code&gt;alloc&lt;/code&gt;、&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;copy&lt;/code&gt;、&lt;code&gt;mutableCopy&lt;/code&gt;开头，则返回对象归调用者所有，否则返回的对象会自动释放。&lt;/p&gt;
&lt;p&gt;4.dealloc方法里要释放指向其他对象的引用，取消键值观测（KVO）和&lt;code&gt;NSNotificationCenter&lt;/code&gt;通知，不要在这里执行异步任务或应该在正常状态下执行的任务，因为这是的对象已经处于正在回收状态了。&lt;/p&gt;
&lt;p&gt;5.ARC默认不生成安全处理异常的代码，设置-fobjc-arc-exceptions标志后可以开启，不过会导致应用程序变大，效率变低。&lt;/p&gt;
&lt;p&gt;6.&lt;code&gt;unsafe_unretain&lt;/code&gt;和&lt;code&gt;weak&lt;/code&gt;都可以用来消除循环引用，区别是前者在引用移除后仍然指向已经回收的对象，后者则会自动设为&lt;code&gt;nil&lt;/code&gt;，所以使用&lt;code&gt;weak&lt;/code&gt;会安全一点，因为向&lt;code&gt;nil&lt;/code&gt;发送消息不会报错。&lt;/p&gt;
&lt;p&gt;7.利用自动释放池可以避免内存峰值的出现。&lt;/p&gt;
&lt;h2 id=&quot;第六章-块与大中枢派发&quot;&gt;&lt;a href=&quot;#第六章-块与大中枢派发&quot; class=&quot;headerlink&quot; title=&quot;第六章 块与大中枢派发&quot;&gt;&lt;/a&gt;第六章 块与大中枢派发&lt;/h2&gt;&lt;p&gt;1.下图是块的内部结构：&lt;br&gt;&lt;img src=&quot;/uploads/block.jpg&quot; alt=&quot;image&quot; title=&quot;block&quot;&gt;&lt;br&gt;上图中首个变量是个isa指针，所以块本身是一个对象。那么块和普通函数有什么区别呢？除了块是个对象外，其实最大的区别就是块比函数多了个上下文环境，块内部可以调用外部的变量，对应上图的&lt;code&gt;variables&lt;/code&gt;，而&lt;code&gt;descriptor&lt;/code&gt;内部则会对捕获的变量进行管理。&lt;/p&gt;
&lt;p&gt;2.块分为全局块（&lt;code&gt;NSConcreteGlobalBlock&lt;/code&gt;）、栈块（&lt;code&gt;NSConcreteStackBlock&lt;/code&gt;）、堆块（&lt;code&gt;NSConcreteMallocBlock&lt;/code&gt;），在ARC中只有全局块和堆块了。&lt;/p&gt;
&lt;p&gt;3.利用&lt;code&gt;typedef&lt;/code&gt;创建块，然后将handler块作为参数传给方法，以降低代码分散程度。这种方法编写类的时候特别要注意块的保留环，记得要把块在适当时机释放掉，解除保留环。在AFNetworking中，是把所有competition块保存在字典中，当请求结束时，再移除，其他开源库的做法也都大同小异。&lt;/p&gt;
&lt;p&gt;4.GCD和&lt;code&gt;NSOperationQueue&lt;/code&gt;：前者是纯C的API，且更加轻量，后者是Objective-C对象，可以取消操作、设置依赖关系、同一队列中各操作的优先级设置。&lt;/p&gt;
&lt;p&gt;5.不要使用&lt;code&gt;dispatch_get_current_queue&lt;/code&gt;，因为往往A线程里面又有B线程，所以在B中检测当前线程就会产生歧义。&lt;/p&gt;
&lt;h2 id=&quot;第七章-系统框架&quot;&gt;&lt;a href=&quot;#第七章-系统框架&quot; class=&quot;headerlink&quot; title=&quot;第七章 系统框架&quot;&gt;&lt;/a&gt;第七章 系统框架&lt;/h2&gt;&lt;p&gt;1.多用块枚举，少用for循环，另外也可以使用for in这种快速遍历的方法。&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;initialize&lt;/code&gt;里面的代码一定要精简。不要在里面调用其他类的方法，因为多个类之间执行&lt;code&gt;load&lt;/code&gt;的顺序是不确定的，而且&lt;code&gt;load&lt;/code&gt;不参与继承机制。&lt;code&gt;initialize&lt;/code&gt;会在类被第一次调用时执行一次，和&lt;code&gt;load&lt;/code&gt;一样，不要再里面调用其他类的方法。&lt;/p&gt;
&lt;p&gt;3.&lt;code&gt;NSTimer&lt;/code&gt;会保留目标对象，所以很容易造成循环引用，调用&lt;code&gt;invalidate&lt;/code&gt;方法可以使timer失效，但是别把这项工作交给调用者，你永远无法保证调用者一定会调用&lt;code&gt;invalidate&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;这本书其实早就看完了，写这几篇博客时，这本书差不多看了快三遍了，里面很多知识点对提升编程质量还是很有帮助的，在看一些开源iOS框架的时候，很多细节上的处理都能在这本书上找到解释。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第五章-内存管理&quot;&gt;&lt;a href=&quot;#第五章-内存管理&quot; class=&quot;headerlink&quot; title=&quot;第五章 内存管理&quot;&gt;&lt;/a&gt;第五章 内存管理&lt;/h2&gt;&lt;p&gt;1.ARC并不会调用&lt;code&gt;retain&lt;/code&gt;、&lt;code&gt;release&lt;/c
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;二&gt;</title>
    <link href="http://intMax.github.io/2015/08/02/effective-objective-c-2/"/>
    <id>http://intMax.github.io/2015/08/02/effective-objective-c-2/</id>
    <published>2015-08-01T16:00:00.000Z</published>
    <updated>2016-03-27T10:29:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;第三章-接口与API设计&quot;&gt;&lt;a href=&quot;#第三章-接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;第三章 接口与API设计&quot;&gt;&lt;/a&gt;第三章 接口与API设计&lt;/h2&gt;&lt;p&gt;1.Objective-C没有命名空间，所以在命名上最好加上前缀以减小冲突的可能，前缀建议采用三个字母（苹果保留使用所有两个字母前缀的权利）。在开发自己的类库时如果用了其他第三方类库，最好将第三方类库也加上前缀，这样可以让使用者使用你的类库的同时也用你的类库中用到第三方类库（有点绕. . .）。&lt;/p&gt;
&lt;p&gt;2.覆写&lt;code&gt;description&lt;/code&gt;方法，打印出一些有用信息帮助调试。&lt;/p&gt;
&lt;p&gt;3.封装一个对象时，对外公开属性最好是只读(&lt;code&gt;readonly&lt;/code&gt;)的，如果要在内部修改可在对象内部重新声明为readwrite。这种模式在AFNetworking有着大量的应用。&lt;/p&gt;
&lt;p&gt;4.私有方法最好加上前缀(p&lt;em&gt; )，前缀不要只用一个下划线(&lt;/em&gt;)，这种做法是苹果预留的。&lt;/p&gt;
&lt;p&gt;5.容器类对象默认执行的是浅拷贝，若要执行深拷贝需要自己编写相关方法。&lt;/p&gt;
&lt;h2 id=&quot;第四章-协议与分类&quot;&gt;&lt;a href=&quot;#第四章-协议与分类&quot; class=&quot;headerlink&quot; title=&quot;第四章 协议与分类&quot;&gt;&lt;/a&gt;第四章 协议与分类&lt;/h2&gt;&lt;p&gt;1.委托属性常用weak来修饰；一个协议里的方法是&lt;code&gt;optional&lt;/code&gt;的，需要先判断委托对象是否实现改方法，如果经常需要判断则可考虑做个缓存。&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;weak&lt;/code&gt;和&lt;code&gt;unsafe_unretain&lt;/code&gt;的区别是前者在相关对象销毁时需要自动清空，后者则不需要。&lt;/p&gt;
&lt;p&gt;3.分类中不要添加属性，必须添加的话可以采用关联对象机制模拟，不推荐。分类的设计初衷是扩展类的功能，而属性是用于数据的封装，因此，属性最好定义在主接口中。&lt;/p&gt;
&lt;p&gt;4.&lt;code&gt;class-continuation&lt;/code&gt;分类（在其他地方看到过叫匿名分类），这本书多次提到了这个概念，对应的部分是：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//SonClass.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SonClass&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;FatherClass&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//SonClass.m&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SonClass&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//class-continuation分类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;code&gt;class-continuation&lt;/code&gt;分类可以用来隐藏实现细节，如系统的WebKit其实大部分是C++编写的，但是对外展示的却是一套整洁的Objective-C接口。&lt;/p&gt;
&lt;p&gt;6.匿名对象，常见的有：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) id&amp;lt;MyDelegate&amp;gt; delegate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这句话的意思是delegate遵循MyDelegate协议，至于它本身是什么类不关心。匿名分类也可以用来对一些第三方类库进行一些简单封装：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyDatabaseConnection&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)connect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)disconnect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)isConnected;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)performQuery:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;*)query;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@ protocol MyDatabaseConnection;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyDatabaseManager&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+sharedInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;MyDatabaseConnection&amp;gt;)connectionWithIdentifier:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;*)identifier;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里隐藏了数据库连接所用的类（可能来自不同框架），而且在后续中，无需改变公共API，就能切换后端实现类。&lt;/p&gt;
&lt;p&gt;6.关于匿名分类的一个面试题：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;、&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;&amp;gt;、&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;的区别&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;：就是用来定义&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;对象的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;：它就是一个指针，它可以指向的类型不仅限于&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;，如&lt;span class=&quot;built_in&quot;&gt;NSProxy&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;&amp;gt;：它指向的对象要求实现&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;所实现的协议，所以说它可以定义&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;、&lt;span class=&quot;built_in&quot;&gt;NSProxy&lt;/span&gt;（它也实现了&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;&amp;gt;）或者其他实现了&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;&amp;gt;的对象。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-接口与API设计&quot;&gt;&lt;a href=&quot;#第三章-接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;第三章 接口与API设计&quot;&gt;&lt;/a&gt;第三章 接口与API设计&lt;/h2&gt;&lt;p&gt;1.Objective-C没有命名空间，所以在命名上最好加上
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;一&gt;</title>
    <link href="http://intMax.github.io/2015/07/15/effective-objective-c-1/"/>
    <id>http://intMax.github.io/2015/07/15/effective-objective-c-1/</id>
    <published>2015-07-14T16:00:00.000Z</published>
    <updated>2016-03-27T10:27:29.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;第一章-熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第一章-熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第一章 熟悉Objective-C&quot;&gt;&lt;/a&gt;第一章 熟悉Objective-C&lt;/h2&gt;&lt;p&gt;1.OC使用动态绑定的消息结构，在runtime才会检查对象类型、决定执行何种代码。runtime是很多功能的基础，如分类、动态添加类等&lt;/p&gt;
&lt;p&gt;2.@class可以向前声明一个类，类似的还有@protocol，这两个关键字告诉编译器我是有这个类或者协议的。&lt;/p&gt;
&lt;p&gt;3.#import不会引起引用头文件死循环和重复引用，它会自动让其中一个失效，而#include用来引用C或C++类型的头文件，会引起死循环。&lt;/p&gt;
&lt;p&gt;4.考虑以下代码：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj1=&lt;span class=&quot;comment&quot;&gt;/*. . .*/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj2=&lt;span class=&quot;comment&quot;&gt;/*. . .*/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj3=&lt;span class=&quot;comment&quot;&gt;/*. . .*/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *arrayA=[&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; arrayWithObjects:obj1,obj2,obj3,&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *arrayB=@[obj1,obj2,obj3];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果obj2=nil会怎样？显然后者初始化数组会报错，而前者虽然不会报错，但是将只有一个对象ojb1。对于前者这很可能不是我们想要的结果，会导致后面出现bug很难追踪，所以推荐使用后者的方式初始化，这样就能尽快定位到问题所在。&lt;/p&gt;
&lt;p&gt;5.多用类型常量，少用#define预处理命令。用extern关键字可对外公开某个常量，AFNetworking中常用这种方式来对外公布一个NSNotification标识符。&lt;/p&gt;
&lt;p&gt;6.枚举尽量用NS_ENUM和NS_OPTIONS宏来定义，这样可以确保枚举是指定的数据类型来实现的。后者还可进行按位或、按位与运算&lt;/p&gt;
&lt;h2 id=&quot;第二章-对象、消息、运行期&quot;&gt;&lt;a href=&quot;#第二章-对象、消息、运行期&quot; class=&quot;headerlink&quot; title=&quot;第二章 对象、消息、运行期&quot;&gt;&lt;/a&gt;第二章 对象、消息、运行期&lt;/h2&gt;&lt;p&gt;1.@synthesis和@dynamic，前者会由编译器在编译期间自动生成getter、setter（假设属性是readwrite），后者告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告。自定义getter、setter可以选择重载他们，也可以在利用runtime期的消息转发机制来实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里插两点：第一，不要在重载的setter方法里有这样的写法self.property=property，应该改为_property=property，否则会引起一个无限循环，这本书在这里的写法是错误的。那么如果要在子类重载这个setter方法该怎么办呢？子类没有_property这个实例变量。这时，可以在子类的实现文件中加上@synthesize property = _property。其实我一开始的想法是用self-&amp;gt;_property来访问的，但是编译不通过。第二，如果同时覆写了getter和setter方法，那么属性对应的实例变量就不存在了，需要自己手动添加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.在对象外部总是应该通过属性来访问实例变量，那么在对象内部呢？直接用实例变量访问速度快，但是会绕过属性特质（copy等），更重要的是不会触发KVO。这本书给的建议的是：写入实例变量时应该用setter方法，而在读取时则直接访问。&lt;/p&gt;
&lt;p&gt;3.尽量避免将可变对象放入容器，容器内部会根据哈希码来对各个对象进行分箱，这意味着在对象被放入容器的时候已经被分好了，如果后来改变了对象，哈希码也会随着改变，这样，之前的分箱就有问题了。&lt;/p&gt;
&lt;p&gt;4.类簇，系统框架中普遍使用了这种模式，如UIButton、NSArray等。以前做网站的时候用过工厂模式，其实类簇基类的内部就是一个工厂，根据传入的参数分别创建相应的对象。相信平常接触比较多的是分类而非类簇，那么两者有什么区别呢？首先，类簇可以隐藏基类背后的具体实现（当然，由于runtime的存在，想要真正隐藏是不可能的），其次，可以用isKindOfClass和isMemberOfClass试试看声明出来的对象是否属于对应的类。类簇声明的对象永远不可能是该基类。&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; maybeAnArray=&lt;span class=&quot;comment&quot;&gt;/*. . .*/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([maybeAnArray class] == [&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; class])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//will never be hit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([[maybeAnArray class] isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; class]])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//will be hit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;5.对象关联机制，运用这种机制可以给分类模拟添加属性，不同属性可以用“键”来区分，属性特质可以用关联类型来表示（OBJC_ASSOCIATION_COPY等）。但是建议不到万不得已的时候不要用这种方法，否则出现“保留环”等内存bug将很难追踪。&lt;/p&gt;
&lt;p&gt;6.消息转发机制&lt;br&gt;&lt;img src=&quot;/uploads/forwarding.jpg&quot; alt=&quot;image&quot; title=&quot;forwarding&quot;&gt;&lt;br&gt;在重写forwardInvocation:时，也要重写methodSignatureForSelector:方法，用来返回相应的方法签名，便于生成一个NSInvocation传递给forwardInvocation:。最后消息未能处理会调用NSObjec的doseNotRecognizeSelector:方法抛出异常。消息传递越往后消耗越大，像@dynamic在resolveInstanceMethod:阶段就可以完成。模拟多继承可以在forwardingTargetForSelector:完成。&lt;/p&gt;
&lt;p&gt;7.方法混写可以交换两个方法的实现、替代原方法的实现等，这项技术一般用于调试，但是最近在看AFNetworking源码时发现，他也用了这项技术，NSURLSessionTask是一个类簇，在iOS7、iOS8中内部继承关系有点不一样，所以用到了这项技术来替换原有的resume、suspend方法。&lt;/p&gt;
&lt;p&gt;8.类对象，每个对象有一个isa指针，指向对应的类，其结构如下：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; *&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class super_class;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; charchar *name;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显然Class本身也是个对象，它指向一个叫“元类（metaclass）”的类，类方法就定义在这里。元类的继承关系和类一样，它继承自父类的元类。根类的元类指针指向自己，从而形成闭环。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章-熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第一章-熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第一章 熟悉Objective-C&quot;&gt;&lt;/a&gt;第一章 熟悉Objective-C&lt;/h2&gt;&lt;p&gt;1.OC使用动态绑定
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
