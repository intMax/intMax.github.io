<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>intMax&#39;Blog</title>
  <subtitle>an iOS developer&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://intMax.github.io/"/>
  <updated>2018-01-07T12:05:19.658Z</updated>
  <id>http://intMax.github.io/</id>
  
  <author>
    <name>intMax</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自动化UI Test</title>
    <link href="http://intMax.github.io/2016/12/10/auto-uitest/"/>
    <id>http://intMax.github.io/2016/12/10/auto-uitest/</id>
    <published>2016-12-09T16:00:00.000Z</published>
    <updated>2018-01-07T12:05:19.658Z</updated>
    
    <content type="html"><![CDATA[<p>App版本迭代速度非常快，每次发版本前都需要回归一些核心测试用例，人工回归枯燥且重复劳动。自动化UI Test虽然不能完全代替人工，但能帮助分担大部分测例。能让机器干的就不要让人来干了，从自动化、UI Test两个方面来讲下怎么实现自动化UI Test。</p>
<h2 id="UI-Test"><a href="#UI-Test" class="headerlink" title="UI Test"></a>UI Test</h2><h3 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h3><blockquote>
<p>UI testing gives you the ability to find and interact with the UI of your app in order to validate the properties and state of the UI elements.</p>
</blockquote>
<p>官方文档说的很简洁明了，UI Test能帮助我们去验证一些UI元素的属性和状态。</p>
<h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><blockquote>
<p>UI tests rests upon two core technologies: the XCTest framework and Accessibility.</p>
<ul>
<li>XCTest provides the framework for UI testing capabilities, integrated with Xcode. Creating and using UI testing expands upon what you know about using XCTest and creating unit tests. You create a UI test target, and you create UI test classes and UI test methods as a part of your project. You use XCTest assertions to validate that expected outcomes are true. You also get continuous integration via Xcode Server and xcodebuild. XCTest is fully compatible with both Objective-C and Swift.</li>
<li>Accessibility is the core technology that allows disabled users the same rich experience for iOS and OS X that other users receive. It includes a rich set of semantic data about the UI that users can use can use to guide them through using your app. Accessibility is integrated with both UIKit and AppKit and has APIs that allow you to fine-tune behaviors and what is exposed for external use. UI testing uses that data to perform its functions.</li>
</ul>
</blockquote>
<p>UI Test主要借助XCTest和Accessibility两个东西，其中XCTest框架帮我做了大部分事情，我们只要往<code>testExample</code>这个方法里填空就能将整个流程跑起来，每个以<code>test</code>开头的方法都会被当成一个测例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBTest</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Put setup code here. This method is called before the invocation of each test method in the class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// In UI tests it is usually best to stop immediately when a failure occurs.</span></span><br><span class="line">        continueAfterFailure = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// UI tests must launch the application that they test. Doing this in setup will make sure it happens for each test method.</span></span><br><span class="line">        <span class="type">XCUIApplication</span>().launch()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tearDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">        <span class="keyword">super</span>.tearDown()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Use recording to get started writing UI tests.</span></span><br><span class="line">        <span class="comment">// Use XCTAssert and related functions to verify your tests produce the correct results.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Accessibility这个东西的作用放到下面讲。</p>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><h4 id="获取指定元素"><a href="#获取指定元素" class="headerlink" title="获取指定元素"></a>获取指定元素</h4><p><img src="/uploads/ui-test-app-ui.png" alt="image"></p>
<p>获取按钮</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过按钮title获取</span></span><br><span class="line">app.buttons[<span class="string">"立即购买"</span>]</span><br><span class="line"><span class="comment">// 通过图片资源名称获取</span></span><br><span class="line"><span class="comment">// btn navigationbar back可以通过Accessibility Inspector这个工具查看</span></span><br><span class="line">app.buttons[<span class="string">"btn navigationbar back"</span>]</span><br></pre></td></tr></table></figure>
<p>获取文本</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接获取</span></span><br><span class="line">app.staticTexts[<span class="string">"豪华午餐"</span>]</span><br><span class="line"><span class="comment">// 通过NSPredicate匹配获取</span></span><br><span class="line"><span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>(format:<span class="string">"label BEGINSWITH %@"</span>, <span class="string">"距离双12"</span>)</span><br><span class="line">app.staticTexts.element(matching:predicate)</span><br></pre></td></tr></table></figure>
<p>上面两种方式只能获取到文本和按钮，但是无法获取UIImageView、UITableViewCell这类控件，那怎么获取到这类元素呢？一种方式是通过下标，但这种方式非常不稳定，很容易出现问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">app.tables.element(boundBy: <span class="number">0</span>).cells.element(boundBy: <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>另一种方式就是通过Accessibility，我们可以为一个元素设置<code>accessibilityIdentifier</code>属性，这样就能获取到这个元素了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成button时设置accessibilityIdentifier</span></span><br><span class="line">- (<span class="built_in">UIButton</span> *)buildButtonWithTitle:(<span class="built_in">NSString</span> *)title identifier:(<span class="built_in">NSString</span> *)identifier handler:(<span class="keyword">void</span> (^)())handler &#123;</span><br><span class="line">    <span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeSystem</span>];</span><br><span class="line">    [button setTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    button.frame = [<span class="keyword">self</span> buildFrame];</span><br><span class="line">    button.accessibilityIdentifier = identifier;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:button];</span><br><span class="line">    [button bk_addEventHandler:^(<span class="keyword">id</span> sender) &#123;</span><br><span class="line">        handler();</span><br><span class="line">    &#125; forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过设置的accessibilityIdentifier来获取这个按钮</span></span><br><span class="line">app.buttons.matching(identifier: <span class="string">"EnterGoodsDetailNormal"</span>).element.tap()</span><br></pre></td></tr></table></figure>
<p>但是这样这种方式对业务的侵入太严重了，在没有一个合适方案的情况下，可以考虑下面这种在<a href="#jump">壳工程</a>中通过hook来设置accessibilityIdentifier。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hook &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *hookArray = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        hookArray = @[ <span class="string">@"SomeClass"</span>, <span class="string">@"AnotherClass"</span> ];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(accessibilityIdentifier);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(eb_accessibilityIdentifier);</span><br><span class="line">        [hookArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            [EBHookUtil eb_swizzleInstanceMethod:<span class="built_in">NSClassFromString</span>(obj) swClass:[EBAppDelegate class] oriSel:originalSelector swSel:swizzledSelector];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)eb_accessibilityIdentifier &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们看到的App界面由文字和图片组成，而UI Test只识别文字，但是有一个特殊的地方，如果图片在按钮上，那么这个按钮所在区域也会被识别，默认identifier就是图片的名称。</p>
<p>借助Accessibility，可以突破上面描述的限制，你可以为某一个控件的accessibilityIdentifier属性赋值，这样，UI Test就能通过这个值获取到相应的控件。Accessibility本身是为有障碍人士设计的，当你的手摸到那个控件时，iPhone会通过语音告诉你这是什么东西。</p>
<p>可惜的是目前还没特别好的方法让Accessibility和业务本身解耦。</p>
<h4 id="忽略后端因素"><a href="#忽略后端因素" class="headerlink" title="忽略后端因素"></a>忽略后端因素</h4><p>后端因素主要指网络和数据，接口返回时机不可控，依赖于网络和服务器，但Test Case需要等到接口返回，并且App布局完成后才能开始，因此，大部分测例开始前，可以加入类似下面这样的代码，来判断App是否渲染完成。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">expectation(<span class="keyword">for</span>: <span class="type">NSPredicate</span>(format:<span class="string">"count &gt; 0"</span>), evaluatedWith: app.tables, handler: <span class="literal">nil</span>)        </span><br><span class="line">waitForExpectations(timeout: <span class="number">3</span>, handler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>另一个便是数据了，接口返回的数据变化不可控，但Test Case却是固定的。解决这个问题我想到了下面两个方案：</p>
<ul>
<li>Mock数据</li>
<li>Test Case开始前，通过调用后端接口，造出相同的数据</li>
</ul>
<p>Mock数据</p>
<p><img src="/uploads/ui-test-mock.png" alt="image"></p>
<p>上图中，点击每个按钮后，都会hook获取数据的方法，将url替换成对应的mock数据url，这些工作都在壳工程中完成，不会对业务代码产生侵入性。</p>
<p>造出相同数据</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在setUp中设置launchArguments</span></span><br><span class="line"><span class="keyword">let</span> app = <span class="type">XCUIApplication</span>()</span><br><span class="line">app.launchArguments = [<span class="string">"cart_testcase_start"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在application:didFinishLaunchingWithOptions:中监测启动</span></span><br><span class="line"><span class="type">NSArray</span> *args = [<span class="type">NSProcessInfo</span> processInfo].arguments;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; args.<span class="built_in">count</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 检测到购物车相关测例即将开始，开始创造前置条件</span></span><br><span class="line">    <span class="keyword">if</span> ([args[i] isEqualToString:@<span class="string">"cart_testcase_start"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 加入购物车</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>上述方案已经能满足大部分Test Case的需求了，但局限性依旧存在，比如UI Test本身无法识别图片，这就意味着无法绕过图形验证码，另外就是短信验证码这类（Android貌似可以做到）。其他测例，理论上只要App内能完成的，Test Case就能覆盖到，但这就涉及到成本问题了，在壳工程内写肯定比在主工程中简单。</p>
<h4 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h4><ul>
<li>类似内存泄露等通用检测，可以统一处理，不必每个测例都写一遍</li>
<li>测例开始后，每隔一段时间，XCTest框架会去扫描一遍App，动画的存在有时候会扰乱你获取界面元素，因此最好关闭动画</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customSetUp</span><span class="params">()</span></span> -&gt; <span class="type">XCUIApplication</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp()</span><br><span class="line">        continueAfterFailure = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> app = <span class="type">XCUIApplication</span>()</span><br><span class="line">        <span class="comment">// 在AppDelegate启动方法中监测animationsEnable，然后设置下关闭动画</span></span><br><span class="line">        app.launchEnvironment = [<span class="string">"animationsEnable"</span>: <span class="string">"NO"</span>]</span><br><span class="line">        memoryLeak()</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里在工程中用了MLeakFinder，所以只要监测弹窗即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memoryLeak</span><span class="params">()</span></span> &#123;</span><br><span class="line">        addUIInterruptionMonitor(withDescription: <span class="string">"Memory Leak, Big Brother"</span>) &#123; (alert) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> alert.staticTexts[<span class="string">"Memory Leak"</span>].exists ||</span><br><span class="line">               alert.staticTexts[<span class="string">"Retain Cycle"</span>].exists ||</span><br><span class="line">               alert.staticTexts[<span class="string">"Object Deallocated"</span>].exists &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 拼接造成内存泄露的原因</span></span><br><span class="line">                <span class="keyword">var</span> msg = <span class="string">""</span></span><br><span class="line">                <span class="keyword">let</span> title = alert.staticTexts.element(boundBy: <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> title.exists &#123;</span><br><span class="line">                    msg += <span class="string">"标题："</span> + title.label</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> reason = alert.staticTexts.element(boundBy: <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> reason.exists &#123;</span><br><span class="line">                    msg += <span class="string">" 原因："</span> + reason.label</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">XCTFail</span>(<span class="string">"Memory Leak, Big Brother "</span> + msg)</span><br><span class="line">                </span><br><span class="line">                alert.buttons[<span class="string">"OK"</span>].tap()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>在自动化方面，主要借助Gitlab CI，具体怎么配置Gitlab CI就不在这里展开了，参考<a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="external">官方文档</a></p>
<p>先来看看最后的流程：</p>
<p>step1：触发自动化流程，<code>git commit -m &quot;班车自动化UI Test&quot; &amp; git push</code></p>
<p>step2：触发流程后，会在gitlab相应项目中生成一个build，等待build结束</p>
<p><img src="/uploads/ui-test-build.jpg" alt="image"></p>
<p>step3：点击build查看详情，通过下图可以看到这次build失败，原因是Detail的5个测例没有通过</p>
<p><img src="/uploads/ui-test-build-info.jpg" alt="image"></p>
<p>step4：在gitlab中显示的日志量比较少，是因为gitlab对日志量做了限制，所以在gitlab中的日志都是经过筛选的关键信息，具体错误原因通过查看服务器日志，下图日志说明了因为内存泄露导致了对应测例失败</p>
<p><img src="/uploads/ui-test-log.jpg" alt="image"></p>
<p>step5：build失败，邮件通知，交由相应组件负责人处理</p>
<p>再来看看.gitlab-ci.yml文件，这个文件是Gitlab CI的配置文件，CI要做什么都可以在这个文件里面描述</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">  - cd Example</span><br><span class="line">  - pod update</span><br><span class="line"></span><br><span class="line">ui_test:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">   # 这里先build一下，防止log日志过多，防止gitlab ci build log exceeded limit of 4194304 bytes.</span><br><span class="line">   - xcodebuild -workspace IntegrationTesting.xcworkspace -scheme IntegrationTesting-Example -destination &apos;platform=iOS Simulator,name=iPhone 7,OS=10.1&apos; build &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">   - xcodebuild -workspace IntegrationTesting.xcworkspace -scheme IntegrationTesting-Example -destination &apos;platform=iOS Simulator,name=iPhone 7,OS=10.1&apos; test | tee Log/`date +%Y%m%d_%H%M%S`.log | grep -A 5 &apos;error:&apos;</span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>这套方案应该算是比较初级的，自动化平台也建议大家用Jenkins，Gitlab CI有点弱，另外，大家有什么好点子可以多多交流，像Accessibility怎么和业务解耦之类的。</p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p><span id="jump">壳工程</span>：主工程包含了所有需要的Pods，壳工程值能运行Pods的环境，可以包含一个或多个Pods</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;App版本迭代速度非常快，每次发版本前都需要回归一些核心测试用例，人工回归枯燥且重复劳动。自动化UI Test虽然不能完全代替人工，但能帮助分担大部分测例。能让机器干的就不要让人来干了，从自动化、UI Test两个方面来讲下怎么实现自动化UI Test。&lt;/p&gt;
&lt;h2 i
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="实用技巧" scheme="http://intMax.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>理解UIButton的imageEdgeInsets和titleEdgeInsets</title>
    <link href="http://intMax.github.io/2016/04/10/uibutton-edgeinsets/"/>
    <id>http://intMax.github.io/2016/04/10/uibutton-edgeinsets/</id>
    <published>2016-04-09T16:00:00.000Z</published>
    <updated>2018-01-07T11:34:53.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>UIButton在日常开发中经常用到，也经常需要做一些定制，这些定制很简单，就是改变image和title的位置而已，默认的image和title位置是这样的：<br><img src="/uploads/pic-0.jpg" alt="image"><br>但你拿到的设计稿却经常是这样的：<br><img src="/uploads/pic-1.jpg" alt="image"><br>有些朋友可能被“毫无规律”的imageEdgeInsets和titleEdgeInsets虐过，所以用UIImageView和UILabel的组合来代替了。本篇博客希望用最简单粗暴的方式–实验，来了解一下imageEdgeInsets和titleEdgeInsets到底是怎么玩的。这是我实验的<a href="https://github.com/intMax/DMTButton" target="_blank" rel="external">Demo</a>，帮你免去了改个数据就要cmd-R的烦恼。</p>
<h2 id="contentVerticalAlignment和contentHorizontalAlignment"><a href="#contentVerticalAlignment和contentHorizontalAlignment" class="headerlink" title="contentVerticalAlignment和contentHorizontalAlignment"></a>contentVerticalAlignment和contentHorizontalAlignment</h2><p>这两个属性是UIControl的，是用来排列内部元素的，用好他们，可以让我们的计算轻松一点。先来看看他们的值：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentVerticalAlignment</span>) &#123;</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentCenter</span>  = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentTop</span>     = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentBottom</span>  = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentFill</span>    = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentHorizontalAlignment</span>) &#123;</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentCenter</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentLeft</span>   = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentRight</span>  = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentFill</span>   = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>4x4总共16种选择，只截了其中4种效果，默认是第一种，其他效果自行脑补：<br><img src="/uploads/pic-2.jpg" alt="image"><br>这里有个令人困惑的地方是，为什么选择UIControlContentHorizontalAlignmentFill时，image和title是这种样子的，而不是想象中的填满。这里可以告诉大家，如果只有image时，完全就是大家想象中的样子，如果只有title时，和UIControlContentHorizontalAlignmentLeft的效果一样，都居左，原因是，title不能像图片一样被拉伸，而只能在宽度被偏小时显示<code>...</code>。至于image和title同时存在时，为什么会是这样，在下一节会解释。</p>
<p>接下来说下我个人是怎么来让计算轻松点的吧，我会把<code>contentVerticalAlignment</code>设为<code>top</code>，<code>contentHorizontalAlignment</code>设为<code>left</code>，这样一来就符合了我们以左上角为坐标原点开始布局的惯性思维。当然这只是一种建议，也许有些人觉得从默认状态计算更加方便，我也赞同，毕竟imageEdgeInsets和titleEdgeInsets只是偏移量，和初始位置在哪并没有什么关系。</p>
<h2 id="imageEdgeInsets和titleEdgeInsets"><a href="#imageEdgeInsets和titleEdgeInsets" class="headerlink" title="imageEdgeInsets和titleEdgeInsets"></a>imageEdgeInsets和titleEdgeInsets</h2><p>上面说了，我喜欢把Alignment设为left-top，所以我一开始的位置是这样的：<br><img src="/uploads/pic-3.jpg" alt="image"><br>因为在初始状态下，imageEdgeInsets和titleEdgeInsets都是0，所以在计算偏移量时，image的top-left-bottom以及title的top-bottom-right均能以button的边界最为参考，那image的right和title的left到底是以上面为参考呢，其实，image的right还是是button的边界为参考的，而title的left却是以image的left为参考的，这也正解释了上一节的疑问，为什么UIControlContentHorizontalAlignmentFill是那种样子的，具体请看图：<br><img src="/uploads/pic-4.jpg" alt="image"><br>搞清楚了这个以后，我们在实际做一个背景小节中介绍的image在上，title在下的button：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> imageTop = (button.height-image.height-title.height)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> titleTop = imageTop+image.height;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> imageLeft = (button.width-image.width)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这里减了image.width，因为title的left是以image的left为参考</span></span><br><span class="line"><span class="built_in">CGFloat</span> titleLeft = (button.width-title.widht)/<span class="number">2</span>-image.width;</span><br><span class="line"></span><br><span class="line">button.imageEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(imageTop, imageLeft, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">button.titleEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(titleTop, titleLeft, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>还有个问题，不知道大家看出来了没有？虽说left-top就能确定位置，但是不是就说right-bottom就没什么用了呢？像我这里全设为了0。答案是否定的，而且这也牵扯出了另一个问题—约束的优先级。先上个结论：</p>
<ul>
<li>top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; imageView不能被压缩</li>
<li>top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; titleLabel水平方向不能被压缩</li>
<li>titleLabel垂直方向不能被压缩 &gt; 不能超出button边界</li>
</ul>
<p>这里的将image和title分开来的原因是这样的：imageView的宽高都能被压缩，titleLabel的宽只能压缩不能拉伸，titleLabel的高只能拉伸不能压缩。从上面三条规则中也能看出，想要超出button边界，只要top-left-bottom-right取负值就行了，当然title在垂直方向上由于不能被压缩，即使是正值也能超出。</p>
<p>接下来拿出实验数据来证明下结论：<br><img src="/uploads/pic-5.jpg" alt="image"></p>
<p>到这里，基本上已经能用好imageEdgeInsets和titleEdgeInsets了，那么还有一个问题，不知道大家注意到没有，title和image是能够超出button边界的，这个其实Apple doc是已经说明说了：</p>
<p>imageEdgeInsets和titleEdgeInsets:</p>
<blockquote>
<p>This property is used only for positioning the image during layout. The button does not use this property to determine intrinsicContentSize and sizeThatFits:.</p>
</blockquote>
<p>contentEdgeInsets:</p>
<blockquote>
<p>The button uses this property to determine intrinsicContentSize and sizeThatFits:.</p>
</blockquote>
<p>所以，如果大家想让image和title在设置insets时不超出边界，只需要同时调整下contentEdgeInsets即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前也被imageEdgeInsets和titleEdgeInsets困扰过，就用了UIImageView和UILabel的组合来代替，为了不影响开发进度，也只能这样做，毕竟靠这个吃饭，不过在技术层面，这你能忍？结束。如有问题，请勘误。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://stackoverflow.com/questions/4564621/aligning-text-and-image-on-uibutton-with-imageedgeinsets-and-titleedgeinsets/5358259#5358259" target="_blank" rel="external">参考链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;UIButton在日常开发中经常用到，也经常需要做一些定制，这些定制很简单，就是改变image和title的位置而已，默认的image和ti
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="实用技巧" scheme="http://intMax.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;三&gt;</title>
    <link href="http://intMax.github.io/2015/08/30/effective-objective-c-3/"/>
    <id>http://intMax.github.io/2015/08/30/effective-objective-c-3/</id>
    <published>2015-08-29T16:00:00.000Z</published>
    <updated>2016-03-27T10:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-内存管理"><a href="#第五章-内存管理" class="headerlink" title="第五章 内存管理"></a>第五章 内存管理</h2><p>1.ARC并不会调用<code>retain</code>、<code>release</code>等方法，而是直接调用其底层C语言版本<code>objc_retain</code>等，所以ARC没有普通的OC消息派发机制。</p>
<p>2.如果<code>setter</code>方法像下面这样写，当新值和旧值相同时就程序就会崩溃。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object&#123;</span><br><span class="line">    [_object release];</span><br><span class="line">    _object=[object retain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.ARC中的命名规则：如果方法名以<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>开头，则返回对象归调用者所有，否则返回的对象会自动释放。</p>
<p>4.dealloc方法里要释放指向其他对象的引用，取消键值观测（KVO）和<code>NSNotificationCenter</code>通知，不要在这里执行异步任务或应该在正常状态下执行的任务，因为这是的对象已经处于正在回收状态了。</p>
<p>5.ARC默认不生成安全处理异常的代码，设置-fobjc-arc-exceptions标志后可以开启，不过会导致应用程序变大，效率变低。</p>
<p>6.<code>unsafe_unretain</code>和<code>weak</code>都可以用来消除循环引用，区别是前者在引用移除后仍然指向已经回收的对象，后者则会自动设为<code>nil</code>，所以使用<code>weak</code>会安全一点，因为向<code>nil</code>发送消息不会报错。</p>
<p>7.利用自动释放池可以避免内存峰值的出现。</p>
<h2 id="第六章-块与大中枢派发"><a href="#第六章-块与大中枢派发" class="headerlink" title="第六章 块与大中枢派发"></a>第六章 块与大中枢派发</h2><p>1.下图是块的内部结构：<br><img src="/uploads/block.jpg" alt="image" title="block"><br>上图中首个变量是个isa指针，所以块本身是一个对象。那么块和普通函数有什么区别呢？除了块是个对象外，其实最大的区别就是块比函数多了个上下文环境，块内部可以调用外部的变量，对应上图的<code>variables</code>，而<code>descriptor</code>内部则会对捕获的变量进行管理。</p>
<p>2.块分为全局块（<code>NSConcreteGlobalBlock</code>）、栈块（<code>NSConcreteStackBlock</code>）、堆块（<code>NSConcreteMallocBlock</code>），在ARC中只有全局块和堆块了。</p>
<p>3.利用<code>typedef</code>创建块，然后将handler块作为参数传给方法，以降低代码分散程度。这种方法编写类的时候特别要注意块的保留环，记得要把块在适当时机释放掉，解除保留环。在AFNetworking中，是把所有competition块保存在字典中，当请求结束时，再移除，其他开源库的做法也都大同小异。</p>
<p>4.GCD和<code>NSOperationQueue</code>：前者是纯C的API，且更加轻量，后者是Objective-C对象，可以取消操作、设置依赖关系、同一队列中各操作的优先级设置。</p>
<p>5.不要使用<code>dispatch_get_current_queue</code>，因为往往A线程里面又有B线程，所以在B中检测当前线程就会产生歧义。</p>
<h2 id="第七章-系统框架"><a href="#第七章-系统框架" class="headerlink" title="第七章 系统框架"></a>第七章 系统框架</h2><p>1.多用块枚举，少用for循环，另外也可以使用for in这种快速遍历的方法。</p>
<p>2.<code>load</code>和<code>initialize</code>里面的代码一定要精简。不要在里面调用其他类的方法，因为多个类之间执行<code>load</code>的顺序是不确定的，而且<code>load</code>不参与继承机制。<code>initialize</code>会在类被第一次调用时执行一次，和<code>load</code>一样，不要再里面调用其他类的方法。</p>
<p>3.<code>NSTimer</code>会保留目标对象，所以很容易造成循环引用，调用<code>invalidate</code>方法可以使timer失效，但是别把这项工作交给调用者，你永远无法保证调用者一定会调用<code>invalidate</code>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这本书其实早就看完了，写这几篇博客时，这本书差不多看了快三遍了，里面很多知识点对提升编程质量还是很有帮助的，在看一些开源iOS框架的时候，很多细节上的处理都能在这本书上找到解释。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第五章-内存管理&quot;&gt;&lt;a href=&quot;#第五章-内存管理&quot; class=&quot;headerlink&quot; title=&quot;第五章 内存管理&quot;&gt;&lt;/a&gt;第五章 内存管理&lt;/h2&gt;&lt;p&gt;1.ARC并不会调用&lt;code&gt;retain&lt;/code&gt;、&lt;code&gt;release&lt;/c
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS hotfix，老思路新框架</title>
    <link href="http://intMax.github.io/2015/08/30/instructional-patch/"/>
    <id>http://intMax.github.io/2015/08/30/instructional-patch/</id>
    <published>2015-08-29T16:00:00.000Z</published>
    <updated>2018-03-10T08:54:31.747Z</updated>
    
    <content type="html"><![CDATA[<p>InstructionalPatch是一个不依赖其他语言引擎的热修复框架，通过下发json文件，再利用runtime来完成热修复。不依赖其他语言引擎好处有：</p>
<ol>
<li>不需要引入多余的引擎</li>
<li>支持的系统版本更多</li>
<li>可控性强，无论是对象转换还是引用管理，当然做的也多</li>
</ol>
<p>坏处：</p>
<ol>
<li>基本语法不支持，诸如if-else、for也需要自己实现</li>
<li>热修复代码可读性差，当然可以通过脚本自动生成json来优化</li>
</ol>
<p>InstructionalPatch基本原理是修改forwardInvocation:，使其指向自己的实现，当要修复某个方法时，让它转发到自己实现的forwardInvocation:中。方法的实现由一系列消息组成，消息之间的参数、变量通过一个环境池（Map）传递，这个环境池会在方法结束时自动清空。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IPViewController</span></span></span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)returnClassMethod &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)logObject:(<span class="built_in">NSString</span> *)obj &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>现在需要在viewDidLoad中打印returnClassMethod中返回的字符串只需要以下指令：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 所有修复指令</span><br><span class="line">    "instructions": [</span><br><span class="line">        &#123;</span><br><span class="line">            // 被修复的类</span><br><span class="line">            "cls": "IPViewController",</span><br><span class="line">            // 被修复方法</span><br><span class="line">            "methodList": [</span><br><span class="line">                &#123;</span><br><span class="line">                    // 修复的方法selector</span><br><span class="line">                    "method": "viewDidLoad",</span><br><span class="line">                    "isStatic": false,</span><br><span class="line">                    // 修复后的方法实现</span><br><span class="line">                    "messages": [</span><br><span class="line">                        &#123;</span><br><span class="line">                            // [super viewDidLoad]</span><br><span class="line">                            "receiver": "super",</span><br><span class="line">                            "message": "viewDidLoad"</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            // NSString *logStr = [IPViewController returnClassMethod];</span><br><span class="line">                            // logStr将会被存入环境池 </span><br><span class="line">                            "returnType": "NSString",</span><br><span class="line">                            "returnObj": "logStr",</span><br><span class="line">                            "receiver": "IPViewController",</span><br><span class="line">                            "isStatic":true,</span><br><span class="line">                            "message": "returnClassMethod"</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            // [self logObject:logStr];</span><br><span class="line">                            "receiver": "self",</span><br><span class="line">                            "message": "logObject:",</span><br><span class="line">                            "args": [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    // 从环境池中取logStr这个对象</span><br><span class="line">                                    "valueKey": "logStr"</span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详情使用方式参见<a href="intmax.github.io">使用文档</a>。</p>
<h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><p>目前大多数hotfix框架都是通过runtime+其他语言引擎来实现的，当然也有像手Q这样直接介入编译阶段的，目前我知道的一些公司在用的有ruby、lua、javascript，基本原理就是利用runtime和这些语言引擎通信，这样就能用其他语言来写OC的代码了。仔细想想这里的引擎起到了什么作用？无非是一个代码运行的环境，简单来说就是栈+基本语法支持，这里的栈是用来记录方法运行产生的变量的，另外在OC中，大部分实现都是通过调用OC方法以及配合if-else、循环来实现的，所以InstructionalPatch的基本思想就是当修复一个方法时，为这个方法生产一个环境池，用来存放方法内部产生的变量；方法的实现是N条消息组成，相当于N个方法调用，这些调用产生的变量和参数通过环境池存取；再加上if-else、while的支持，实现了一个简易版的热修复框架。</p>
<h4 id="environmentPool"><a href="#environmentPool" class="headerlink" title="environmentPool"></a>environmentPool</h4><p>环境池实际上就是一个全局的静态Map，用key-value的形式存取，当进入一个方法时，自动为这个方法开辟一块空间来存放产生的变量，退出方法时再清空这块空间。但实际上，方法实现中经常有异步的block，这时候方法结束了并不能立即清空，否则block真正在执行的时候就没地方去取相应的变量了。为了解决这个问题，借鉴了一下OC的引用计数，当方法开始时引用+1，发现有block时引用也+1，方法执行结束、block执行结束引用-1，这样就能避免环境池过早释放的问题了。但是这又引出了另外一个问题，像一个网络请求一般有success和failure两个block，但是最终却只有一个能被执行，这就导致引用计数始终大于0，而且在代码上并不能判断一个block会不会被执行，所以只能是让用户手动在json的message中手动指定引用的次数environmentPoolRefCount。</p>
<p>既然environmentPool是个Map，那么就只能存取id类型的变量，所以对一些基本类型的变量要做一层包装，在使用的时候再解包。变量类型主要通过NSMethodSignature中的信息根据<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">Type Encodings</a>来判断。</p>
<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>在具体的业务中，block要么作为被修复方法参数要被调用，要么作为被调用方法的参数要被构造，这样问题就变成了：</p>
<ol>
<li>如何调用参数、返回值不确定的block变量</li>
<li>如何构造参数类型、个数不确定block变量</li>
</ol>
<p>要确定一个方法的参数、返回值信息，首先就要知道这个方法签名，block也一样，所以第一个问题的核心就是拿到block变量的签名。虽然系统没提供，不过github很多库和runtime源码中都有相关的实现，具体代码如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> IPBlockLayout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; </span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> IPBlockDescriptor *descriptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> IPBlockDescriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  IP_BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</span><br><span class="line">  IP_BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMethodSignature</span> * _IPBlockSignature(<span class="keyword">id</span> block) &#123;</span><br><span class="line">    <span class="keyword">struct</span> IPBlockLayout *bp = (__bridge <span class="keyword">struct</span> IPBlockLayout *)block;</span><br><span class="line">    <span class="keyword">if</span> (bp &amp;&amp; (bp-&gt;flags &amp; IP_BLOCK_HAS_SIGNATURE)) &#123;</span><br><span class="line">        <span class="keyword">void</span> *signatureLocation = bp-&gt;descriptor;</span><br><span class="line">        signatureLocation += <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line">        signatureLocation += <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bp-&gt;flags &amp; IP_BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            signatureLocation += <span class="keyword">sizeof</span>(<span class="keyword">void</span>(*)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src));</span><br><span class="line">            signatureLocation += <span class="keyword">sizeof</span>(<span class="keyword">void</span> (*)(<span class="keyword">void</span> *src));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)signatureLocation);</span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *blockSignature = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br><span class="line">        <span class="keyword">return</span> blockSignature;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拿到签名后，一切就变得简单了，直接利用<code>NSInvocation</code>来调用就好。不过这里仍要注意一点：一般方法的参数都是都是从index=2开始设置的，前两个分别是self和selector，但是blcok因为没有selector（这里没找到什么资料，仅仅是我猜测的原因），所以要从index=1开始设置。</p>
<p>第二个问题就很麻烦了，没有签名，也没有一个通用的类型来代表id、int、double、float等等，只能退而求其次，使用<code>void *</code> ，且最多支持4个参数，这点和<a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">JSPatch</a>遇到的问题一样。这样block就有很大的限制了，但是看起来也是够用了。</p>
<h4 id="json结构"><a href="#json结构" class="headerlink" title="json结构"></a>json结构</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IPIntructionModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;IPIntructionClassModel *&gt; *instructions;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IPIntructionClassModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *cls;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;IPIntructionMethodModel *&gt; *methodList;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IPIntructionMethodModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *method;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isStatic;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isMsgForwardStret;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;IPIntructionMessageModel *&gt; *messages;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IPIntructionMessageModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *returnType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *returnObj;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *receiver;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *message;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isStatic;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isIfSnippet;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isWhileSnippet;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isReturnSnippet;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> environmentPoolRefCount;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *blockKey;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;IPIntructionArgumentModel *&gt; *args;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IPIntructionArgumentModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *type;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *valueKey;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *stringValue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">double</span> digital;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *digitalType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *blockParameterTypes;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *blockParameterPrefix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;IPIntructionMessageModel *&gt; *innerMessage;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>IPIntructionArgumentModel这里有个innerMessage，这是实现block、if-else、while的关键，但是代码实现上其实递归调用，每次调用都能捕获上一层的变量。</p>
<p>关于Model的另外一个问题是序列化，这里是继承自NSObject的，但好多序列化工具都需要继承自指定的类，想过用protocol，但是这会导致这个Model需要生成protocol里面的属性的getter、setter，编写起来有点麻烦。所以外部如果需要传递自己的Model，只要保证有上述所有属性结构就好，其他的就让动态语言帮我们去解决，暂时没找到好的方法。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>一个自动生成json文件的脚本，提高代码可读性，更接近OC</li>
<li>更友好方式去支持自定义Model</li>
<li>支持GCD</li>
<li>支持更多除了if-else、while的基本语法<br>……</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大致思路说完了，单测测例、技术细节处理在慢慢完善中，整体实现也非常简单。这里多说一句，热修复已经被苹果一棒子打死了，现在在用的一些热修复框架也是主要是靠绕过苹果审核，但是我没找到很好的介绍苹果审核手段相关技术文章，求！</p>
<p>开源地址：<a href="https://github.com/intMax/InstructionPatch" target="_blank" rel="external">InstructionPatch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InstructionalPatch是一个不依赖其他语言引擎的热修复框架，通过下发json文件，再利用runtime来完成热修复。不依赖其他语言引擎好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不需要引入多余的引擎&lt;/li&gt;
&lt;li&gt;支持的系统版本更多&lt;/li&gt;
&lt;li&gt;可控性强，无
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;二&gt;</title>
    <link href="http://intMax.github.io/2015/08/02/effective-objective-c-2/"/>
    <id>http://intMax.github.io/2015/08/02/effective-objective-c-2/</id>
    <published>2015-08-01T16:00:00.000Z</published>
    <updated>2018-01-07T12:04:03.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-接口与API设计"><a href="#第三章-接口与API设计" class="headerlink" title="第三章 接口与API设计"></a>第三章 接口与API设计</h2><p>1.Objective-C没有命名空间，所以在命名上最好加上前缀以减小冲突的可能，前缀建议采用三个字母（苹果保留使用所有两个字母前缀的权利）。在开发自己的类库时如果用了其他第三方类库，最好将第三方类库也加上前缀，这样可以让使用者使用你的类库的同时也用你的类库中用到第三方类库（有点绕. . .）。</p>
<p>2.覆写<code>description</code>方法，打印出一些有用信息帮助调试。</p>
<p>3.封装一个对象时，对外公开属性最好是只读(<code>readonly</code>)的，如果要在内部修改可在对象内部重新声明为readwrite。这种模式在AFNetworking有着大量的应用。</p>
<p>4.私有方法最好加上前缀(p<em> )，前缀不要只用一个下划线( </em> )，这种做法是苹果预留的。</p>
<p>5.容器类对象默认执行的是浅拷贝，若要执行深拷贝需要自己编写相关方法。</p>
<h2 id="第四章-协议与分类"><a href="#第四章-协议与分类" class="headerlink" title="第四章 协议与分类"></a>第四章 协议与分类</h2><p>1.委托属性常用weak来修饰；一个协议里的方法是<code>optional</code>的，需要先判断委托对象是否实现改方法，如果经常需要判断则可考虑做个缓存。</p>
<p>2.<code>weak</code>和<code>unsafe_unretain</code>的区别是前者在相关对象销毁时需要自动清空，后者则不需要。</p>
<p>3.分类中不要添加属性，必须添加的话可以采用关联对象机制模拟，不推荐。分类的设计初衷是扩展类的功能，而属性是用于数据的封装，因此，属性最好定义在主接口中。</p>
<p>4.<code>class-continuation</code>分类（在其他地方看到过叫匿名分类），这本书多次提到了这个概念，对应的部分是：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SonClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SonClass</span> : <span class="title">FatherClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SonClass.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SonClass</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//class-continuation分类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>5.<code>class-continuation</code>分类可以用来隐藏实现细节，如系统的WebKit其实大部分是C++编写的，但是对外展示的却是一套整洁的Objective-C接口。</p>
<p>6.匿名对象，常见的有：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;MyDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></p>
<p>这句话的意思是delegate遵循MyDelegate协议，至于它本身是什么类不关心。匿名分类也可以用来对一些第三方类库进行一些简单封装：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyDatabaseConnection</span></span></span><br><span class="line">-(<span class="keyword">void</span>)connect;</span><br><span class="line">-(<span class="keyword">void</span>)disconnect;</span><br><span class="line">-(<span class="built_in">BOOL</span>)isConnected;</span><br><span class="line">-(<span class="built_in">NSArray</span> *)performQuery:(<span class="built_in">NSString</span>*)query;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">@ protocol MyDatabaseConnection;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDatabaseManager</span> : <span class="title">NSObject</span></span></span><br><span class="line">+sharedInstance;</span><br><span class="line">-(<span class="keyword">id</span>&lt;MyDatabaseConnection&gt;)connectionWithIdentifier:(<span class="built_in">NSString</span>*)identifier;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这里隐藏了数据库连接所用的类（可能来自不同框架），而且在后续中，无需改变公共API，就能切换后端实现类。</p>
<p>6.关于匿名分类的一个面试题：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span>、<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;、<span class="built_in">NSObject</span>的区别</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSObject</span>：就是用来定义<span class="built_in">NSObject</span>对象的。</span><br><span class="line"><span class="keyword">id</span>：它就是一个指针，它可以指向的类型不仅限于<span class="built_in">NSObject</span>，如<span class="built_in">NSProxy</span>。</span><br><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;：它指向的对象要求实现<span class="built_in">NSObject</span>所实现的协议，所以说它可以定义<span class="built_in">NSObject</span>、<span class="built_in">NSProxy</span>（它也实现了&lt;<span class="built_in">NSObject</span>&gt;）或者其他实现了&lt;<span class="built_in">NSObject</span>&gt;的对象。</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-接口与API设计&quot;&gt;&lt;a href=&quot;#第三章-接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;第三章 接口与API设计&quot;&gt;&lt;/a&gt;第三章 接口与API设计&lt;/h2&gt;&lt;p&gt;1.Objective-C没有命名空间，所以在命名上最好加上
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 阅读笔记&lt;一&gt;</title>
    <link href="http://intMax.github.io/2015/07/15/effective-objective-c-1/"/>
    <id>http://intMax.github.io/2015/07/15/effective-objective-c-1/</id>
    <published>2015-07-14T16:00:00.000Z</published>
    <updated>2016-03-27T10:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-熟悉Objective-C"><a href="#第一章-熟悉Objective-C" class="headerlink" title="第一章 熟悉Objective-C"></a>第一章 熟悉Objective-C</h2><p>1.OC使用动态绑定的消息结构，在runtime才会检查对象类型、决定执行何种代码。runtime是很多功能的基础，如分类、动态添加类等</p>
<p>2.@class可以向前声明一个类，类似的还有@protocol，这两个关键字告诉编译器我是有这个类或者协议的。</p>
<p>3.#import不会引起引用头文件死循环和重复引用，它会自动让其中一个失效，而#include用来引用C或C++类型的头文件，会引起死循环。</p>
<p>4.考虑以下代码：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1=<span class="comment">/*. . .*/</span>;</span><br><span class="line"><span class="keyword">id</span> obj2=<span class="comment">/*. . .*/</span>;</span><br><span class="line"><span class="keyword">id</span> obj3=<span class="comment">/*. . .*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *arrayA=[<span class="built_in">NSArray</span> arrayWithObjects:obj1,obj2,obj3,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *arrayB=@[obj1,obj2,obj3];</span><br></pre></td></tr></table></figure></p>
<p>如果obj2=nil会怎样？显然后者初始化数组会报错，而前者虽然不会报错，但是将只有一个对象ojb1。对于前者这很可能不是我们想要的结果，会导致后面出现bug很难追踪，所以推荐使用后者的方式初始化，这样就能尽快定位到问题所在。</p>
<p>5.多用类型常量，少用#define预处理命令。用extern关键字可对外公开某个常量，AFNetworking中常用这种方式来对外公布一个NSNotification标识符。</p>
<p>6.枚举尽量用NS_ENUM和NS_OPTIONS宏来定义，这样可以确保枚举是指定的数据类型来实现的。后者还可进行按位或、按位与运算</p>
<h2 id="第二章-对象、消息、运行期"><a href="#第二章-对象、消息、运行期" class="headerlink" title="第二章 对象、消息、运行期"></a>第二章 对象、消息、运行期</h2><p>1.@synthesis和@dynamic，前者会由编译器在编译期间自动生成getter、setter（假设属性是readwrite），后者告诉编译器，不自动生成getter/setter方法，避免编译期间产生警告。自定义getter、setter可以选择重载他们，也可以在利用runtime期的消息转发机制来实现。</p>
<blockquote>
<p>这里插两点：第一，不要在重载的setter方法里有这样的写法self.property=property，应该改为_property=property，否则会引起一个无限循环，这本书在这里的写法是错误的。那么如果要在子类重载这个setter方法该怎么办呢？子类没有_property这个实例变量。这时，可以在子类的实现文件中加上@synthesize property = _property。其实我一开始的想法是用self-&gt;_property来访问的，但是编译不通过。第二，如果同时覆写了getter和setter方法，那么属性对应的实例变量就不存在了，需要自己手动添加。</p>
</blockquote>
<p>2.在对象外部总是应该通过属性来访问实例变量，那么在对象内部呢？直接用实例变量访问速度快，但是会绕过属性特质（copy等），更重要的是不会触发KVO。这本书给的建议的是：写入实例变量时应该用setter方法，而在读取时则直接访问。</p>
<p>3.尽量避免将可变对象放入容器，容器内部会根据哈希码来对各个对象进行分箱，这意味着在对象被放入容器的时候已经被分好了，如果后来改变了对象，哈希码也会随着改变，这样，之前的分箱就有问题了。</p>
<p>4.类簇，系统框架中普遍使用了这种模式，如UIButton、NSArray等。以前做网站的时候用过工厂模式，其实类簇基类的内部就是一个工厂，根据传入的参数分别创建相应的对象。相信平常接触比较多的是分类而非类簇，那么两者有什么区别呢？首先，类簇可以隐藏基类背后的具体实现（当然，由于runtime的存在，想要真正隐藏是不可能的），其次，可以用isKindOfClass和isMemberOfClass试试看声明出来的对象是否属于对应的类。类簇声明的对象永远不可能是该基类。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> maybeAnArray=<span class="comment">/*. . .*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>([maybeAnArray class] == [<span class="built_in">NSArray</span> class])&#123;</span><br><span class="line"><span class="comment">//will never be hit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>([[maybeAnArray class] isKindOfClass:[<span class="built_in">NSArray</span> class]])&#123;</span><br><span class="line"><span class="comment">//will be hit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.对象关联机制，运用这种机制可以给分类模拟添加属性，不同属性可以用“键”来区分，属性特质可以用关联类型来表示（OBJC_ASSOCIATION_COPY等）。但是建议不到万不得已的时候不要用这种方法，否则出现“保留环”等内存bug将很难追踪。</p>
<p>6.消息转发机制<br><img src="/uploads/forwarding.jpg" alt="image" title="forwarding"><br>在重写forwardInvocation:时，也要重写methodSignatureForSelector:方法，用来返回相应的方法签名，便于生成一个NSInvocation传递给forwardInvocation:。最后消息未能处理会调用NSObjec的doseNotRecognizeSelector:方法抛出异常。消息传递越往后消耗越大，像@dynamic在resolveInstanceMethod:阶段就可以完成。模拟多继承可以在forwardingTargetForSelector:完成。</p>
<p>7.方法混写可以交换两个方法的实现、替代原方法的实现等，这项技术一般用于调试，但是最近在看AFNetworking源码时发现，他也用了这项技术，NSURLSessionTask是一个类簇，在iOS7、iOS8中内部继承关系有点不一样，所以用到了这项技术来替换原有的resume、suspend方法。</p>
<p>8.类对象，每个对象有一个isa指针，指向对应的类，其结构如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;  </span><br><span class="line">    Class isa;  </span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;  </span><br><span class="line">    Class isa;  </span><br><span class="line">    Class super_class;  </span><br><span class="line">    <span class="keyword">const</span> charchar *name;  </span><br><span class="line">    <span class="keyword">long</span> version;  </span><br><span class="line">    <span class="keyword">long</span> info;  </span><br><span class="line">    <span class="keyword">long</span> instance_size;  </span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars;  </span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists;  </span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache;  </span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols;  </span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>显然Class本身也是个对象，它指向一个叫“元类（metaclass）”的类，类方法就定义在这里。元类的继承关系和类一样，它继承自父类的元类。根类的元类指针指向自己，从而形成闭环。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章-熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第一章-熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第一章 熟悉Objective-C&quot;&gt;&lt;/a&gt;第一章 熟悉Objective-C&lt;/h2&gt;&lt;p&gt;1.OC使用动态绑定
    
    </summary>
    
      <category term="iOS" scheme="http://intMax.github.io/categories/iOS/"/>
    
    
      <category term="阅读笔记" scheme="http://intMax.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
